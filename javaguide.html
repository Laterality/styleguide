<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Google Java Style Guide</title>
<link rel="stylesheet" type="text/css" href="javaguide.css">
<script language="javascript" src="include/styleguide.js"></script>
<link rel="shortcut icon" type="image/x-icon" href="https://www.google.com/favicon.ico" />
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google Java Style Guide</h1>
<div class="vertical_toc" id="tocDiv"></div>

<div class="main_body">

<h2 id="s1-introduction">1 소개</h2>

<p>이 문서는 자바&#8482; 프로그래밍 언어의 소스코드를 위한 구글의 
<strong>완전한</strong> 코딩 표준의 역할을 합니다.
자바 소스 파일은 이곳에 나와 있는 규칙들을 준수한 경우에만 <em>구글 스타일</em>로 표시됩니다.

<p>다른 프로그래밍 스타일 가이드처럼, 서식의 미적인 부분 뿐만 아니라 
다른 형식의 관례나 코딩 표준 또한 문제에 포함됩니다. 하지만, 이 문서는 우리가 
보편적으로 따르는 명확한 규칙에 초점을 맞추고 (인간이나 도구에 의해)명확하게 
시행할 수 없는 조언은 피합니다.</p>

<h3 id="s1.1-terminology">1.1 용어 노트</h3>

<p>이 문서에서는 달리 명시되지 않는 한 다음과 같습니다:</p>
<ol>
	<li><em>클래스</em>는 "보통의" 클래스, 열거(enum) 클래스, 인터페이스나 
	어노테이션 타입(<code class="prettyprint lang-java">@interface</code>)을 
	통틀어 의미합니다.</li>

	<li>(클래스의) <em>멤버</em>는 중첩 클래스, 필드, 메서드, 
	<em>혹은 생성자</em>를 통틀어 이릅니다. 즉, 초기자(initializer)와 주석을 
	제외한 클래스의 모든 최상위 요소를 의미합니다.</li>

	<li><em>주석</em>은 언제나 <em>구현</em> 주석을 의미합니다. 
	일반적인 용어인 "Javadoc"을 사용하는 대신, "문서화 주석"이라는 말을 사용하지 않습니다. </li>
</ol>

<p>다른 "용어 노트"는 종종 문서 중간에 나올 것입니다.</p>


<h3 id="s1.2-guide-notes">1.2 가이드 노트</h3>

<p>이 문서의 예시 코드는 <strong>비 규범적</strong>입니다. 이는 예시들이 구글 스타일이라 하더라도, 세련된 코드를 작성하는 유일한 방법을 설명하는 것이 아닐 수 있음을 의미합니다. 예시들에 적용된 선택적 서식은 규칙으로 강제되지 않습니다.</p>

<h2 id="s2-source-file-basics">2 소스 파일 기본</h2>

<h3 id="s2.1-file-name">2.1 파일명</h3>

<p>소스 파일명은 포함하고 있는 최상위 클래스의 대소문자를 구분하는 이름에 
<code>.java</code>확장자를 더한 이름으로 구성됩니다.</p>

<h3 id="s2.2-file-encoding">2.2 파일 인코딩: UTF-8</h3>

<p>소스파일은 <strong>UTF-8</strong>로 인코딩됩니다.</p>

<h3 id="s2.3-special-characters">2.3 특수 문자</h3>

<h4 id="s2.3.1-whitespace-characters">2.3.1 공백 문자</h4>

<p>라인 종결 시퀀스와는 달리, <strong>ASCII 수평 공백 문자</strong>
(<strong>0x20</strong>)은 소스 파일 어디서나 나타나는 유일한 공백 
문자입니다. 이는 다음을 의미합니다:</p>

<ol>
	<li>문자열과 문자 리터럴의 모든 다른 공백 문자는 이스케이프됩니다.</li>

	<li>탭 문자는 들여쓰기에 <strong>사용되지 않</strong>습니다.</li>
</ol>

<h4 id="s2.3.2-special-escape-sequences">2.3.2 특수 이스케이프 시퀀스</h4>

<p>For any character that has a
<a href="http://docs.oracle.com/javase/tutorial/java/data/characters.html">
  특수 이스케이프 시퀀스</a>를 가진 문자에서
(<code class="prettyprint lang-java">\b</code>,
<code class="prettyprint lang-java">\t</code>,
<code class="prettyprint lang-java">\n</code>,
<code class="prettyprint lang-java">\f</code>,
<code class="prettyprint lang-java">\r</code>,
<code class="prettyprint lang-java">\"</code>,
<code class="prettyprint lang-java">\'</code> 와
<code class="prettyprint lang-java">\\</code>), 이 시퀀스는 대응되는 8진수
(e.g.&#160;<code class="badcode">\012</code>) 혹은 유니코드
(e.g.&#160;<code class="badcode">\u000a</code>) 이스케이프 보다 많이 
사용됩니다..</p>

<h4 id="s2.3.3-non-ascii-characters">2.3.3 비 아스키 문자</h4>

<p>나머지 비 아스키 문자의 경우, 실제 유니코드 문자
(e.g.&#160;<code class="prettyprint lang-java">&#8734;</code>) 혹은 동등한 
유니코드 이스케이프 (e.g.&#160;<code class="prettyprint 
lang-java">\u221e</code>) 중의 하나가 사용됩니다. 문자열 리터럴과 주석 외부의 
유니코드 이스케이프가 좋지 않다고 하더라도, 선택은 오로지 어느 쪽이 코드를 
<strong>읽고 이해하기에 더 쉬운가</strong>에 달렸습니다.</p>

<p class="tip"><strong>팁:</strong> 유니코드 이스케이프를 사용하는 경우에 실제 유니코드 문자가 사용되면, 설명 주석은 매우 유용할 수 있습니다.</p>

<p>예시:</p>

<table>
  <tbody><tr>
    <th>예시</th>
    <th>논의</th>
  </tr>

  <tr>
    <td><code class="prettyprint lang-java">String unitAbbrev = "&#956;s";</code></td>
    <td>최선: 주석이 없어도 완벅합니다.</td>
  </tr>

  <tr>
    <td><code class="prettyprint lang-java">String unitAbbrev = "\u03bcs"; // "&#956;s"</code></td>
    <td>쓸 수는 있지만 굳이 이렇게 할 이유는 없습니다.</td>
  </tr>

  <tr>
    <td><code class="prettyprint lang-java">String unitAbbrev = "\u03bcs";
      // Greek letter mu, "s"</code></td>
    <td>쓸 수는 있지만 어색하고 실수를 유발할 수 있습니다.</td>
  </tr>

  <tr>
    <td><code class="badcode">String unitAbbrev = "\u03bcs";</code></td>
    <td>최악: 읽는 사람은 이게 뭔지 모를 겁니다.</td>
  </tr>

  <tr>
     <td><code class="prettyprint lang-java">return '\ufeff' + content;
       // byte order mark</code></td>
     <td>양호: 비 출력 문자에 대해 이스케이프를 사용합니다, 필요한 경우 주석도 
		답니다.</td>
  </tr>
</tbody></table>

<p class="tip"><strong>팁 :</strong> 일부 프로그램은 비 아스키 문자를 적절하게 
처리하지 못할 수 있으므로 코드를 일긱 어렵게 만들지 마십시오. 만약 발생한다면, 
프로그램은 <strong>이상</strong>이 생길 것이고 <strong>고쳐져</strong>야 
합니다.</p>

<a name="filestructure"></a>
<h2 id="s3-source-file-structure">3 소스 파일 구조</h2>

<div>
<p>소스 파일은 <strong>다음과 같이</strong> 구성됩니다:</p>
<ol>
  <li>라이센스나 저작권이 있는 경우, 이에 대한 정보</li>
  <li>Package문</li>
  <li>Import문</li>
  <li>정확히 하나의 최상위 클래스</li>
</ol>
</div>

<p><strong>정확히 하나의 빈 행</strong>은 각 영역을 분리합니다.</p>

<h3 id="s3.1-copyright-statement">3.1 라이센스나 저작권이 있는 경우, 이에 대한 정보</h3>

<p>파일에 라이센스나 저작권이 있는 경우, 여기에 위치합니다.</p>



<h3 id="s3.2-package-statement">3.2 Package문</h3>

<p>package문은 <strong>line-wrap</strong>(줄이 꽉찬 경우 다음 줄로 넘어가는 것)
하지 않습니다. 행 제한 (Section 4.4,
<a href="#s4.4-column-limit">행 제한: 100</a>)은 package문에 적용하지 
않습니다.</p>

<a name="imports"></a>
<h3 id="s3.3-import-statements">3.3 Import문</h3>

<h4 id="s3.3.1-wildcard-imports">3.3.1 와일드카드(*) import는 사용하지 않습니다</h4>

<p>static 또는 기타 <strong>와일드카드 import</strong>는 <strong>사용되지 않습니다</strong>.</p>

<h4 id="s3.3.2-import-line-wrapping">3.3.2 line-wrapping 금지</h4>

<p>Import 문은 <strong>line-wrap</strong>하지 않습니다. 행 제한(Section 4.4,
<a href="#s4.4-column-limit">행 제한: 100</a>)은 import문에 적용하지 않습니다.</p>

<h4 id="s3.3.3-import-ordering-and-spacing">3.3.3 순서 및 간격</h4>

<p>Import는 다음 순서를 따릅니다:</p>

<ol>
  <li>단일 블럭의 모든 static import.</li>
  <li>단일 블럭의 모든 non-static import.</li>
</ol>

<p>만일 static 과 non-static import 둘 다 있는 경우, 한 개의 빈 줄로 
두 개의 블럭으로 나눕니다. import문 사이에 다른 공백은 없습니다.</p>

<p>각 블록 안의 import 이름은 ASCII 순서로 정렬됩니다. (<strong>Note:</strong>
'.' 이후부터 ';' 전까지를 정렬하므로, import<em>문</em>이 ASCII 순서인 것과는 다릅니다.)</p>



<h4 id="s3.3.4-import-class-not-static">3.3.4 클래스에 대한 static import 금지</h4>

<p>Static import 는 중첩 클래스에 사용되지 않습니다. 이들은 일반 import로 
임포트됩니다.</p>

<h3 id="s3.4-class-declaration">3.4 클래스 선언</h3>

<a name="oneclassperfile"></a>
<h4 id="s3.4.1-one-top-level-class">3.4.1 정확히 하나의 최상위 클래스 선언</h4>

<p>소스 파일에는 각각 하나의 고유한 최상위 클래스가 위치합니다.</p>

<a name="s3.4.2-class-member-ordering"></a>
<h4 id="s3.4.2-ordering-class-contents">3.4.2 클래스 내용의 순서</h4>

<p>클래스의 멤버와 초기자(initializer)에 대해 여러분이 선택한 순서는 코드를 
이해하는 데에 있어 큰 효과를 낼 수 있습니다. 하지만 이를 어떻게 할 지에 대한 
하나의 명확한 방법은 없습니다. 서로 다른 클래스들은 각 내용들을 서로 다른 
방법으로 정렬하고 있을 수 있습니다.</p>

<p>중요한 것은 각 클래스가 클래스의 작성자가 설명할 수 있는 
<strong><em>어떤</em></strong> 논리적인 순서를 사용한다는 것입니다. 예를 들어,
 새로운 메서드를 습관적으로 클래스의 마지막에 추가하는 것은 "추가된 날짜의 시간 순서"라는 논리적이지 않은 순서를 만들게 됩니다.</p>

<a name="overloads"></a>
<h5 id="s3.4.2.1-overloads-never-split">3.4.2.1 오버로드: 나누기 절대 금지</h5>

<p>클래스가 복수의 생성자 혹은 같은 이름의 복수의 메서드를 가질 때, 이들은 
순서대로 나열하며, (private 멤버라고 하더라도) 그 사이에 다른 코드는 없습니다.
</p>

<h2 id="s4-formatting">4 서식</h2>

<p class="terminology"><strong>용어 노트:</strong> <em>블럭같은 구조</em>는 
클래스의 본문, 메서드 혹은 생성자를 의미합니다. 주목할 점은, Section 4.8.3.1 의
<a href="#s4.8.3.1-array-initializers">배열 초기자</a>에서, 임의의 배열 
초기자는 선택적으로 블럭같은 구조로 취급될 <em>수</em> 있습니다.</p>

<a name="braces"></a>
<h3 id="s4.1-braces">4.1 중괄호</h3>

<h4 id="s4.1.1-braces-always-used">4.1.1 중괄호는 선택 사항에서 사용</h4>

<p>중괄호는 
<code class="prettyprint lang-java">if</code>,
<code class="prettyprint lang-java">else</code>,
<code class="prettyprint lang-java">for</code>,
<code class="prettyprint lang-java">do</code> 그리고
<code class="prettyprint lang-java">while</code>문에서 사용되며, 내용이 비어 있거나 단 한줄만 포함하고 있더라도 사용합니다.</p>

<h4 id="s4.1.2-blocks-k-r-style">4.1.2 비어 있지 않은 블록: K &amp; R 
스타일</h4>

<p><em>비어있지 않은</em> 블럭과 블럭같은 구조에 대해, 괄호는 Kernighan and Ritchie 스타일을 따릅니다
("<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">이집트식 괄호</a>"):</p>

<ul>
  <li>여는 괄호 앞에 개행을 하지 않는다.</li>

  <li>여는 괄호 뒤에 개행한다.</li>

  <li>닫는 괄호 앞에 개행한다.</li>

  <li>괄호가 문(statement) 혹은 메서드 내용, 생성자, 혹은 <em>명명된</em> 
  클래스를 끝내는 <em>경우에만</em> 닫는 괄호 뒤에 개행한다.
  예를 들어, 
  <code class="prettyprint lang-java">else</code> 나 쉼표가 뒤에 오는 경우에는 괄호 뒤에 개행하지 <em>않는다</em>.</li>
</ul>

<p>예시:</p>

<pre class="prettyprint lang-java">return () -&gt; {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
  }
};
</pre>

<p>열거(enum) 클래스에 대한 몇몇 예외 사항이 Section 4.8.1에 있습니다,
<a href="#s4.8.1-enum-classes">Enum classes</a>.</p>

<a name="emptyblocks"></a>
<h4 id="s4.1.3-braces-empty-blocks">4.1.3 빈 블록: 간결하게</h4>

<p>빈 블럭이나 블럭같은 구조는 아마 K &amp; R 스타일 (
<a href="#s4.1.2-blocks-k-r-style">Section 4.1.2</a>에 설명된 대로)을 따를 
것입니다. 대신, <em>멀티 블럭문</em>(직접적으로 복수의 블럭을 포함하는 경우:
<code class="prettyprint lang-java">if/else</code> or
<code class="prettyprint lang-java">try/catch/finally</code>)의 일부가 
<strong>아닌 한</strong>,
사이에 어떤 문자나 개행도 없이 여는 괄호 다음에 바로 닫는 
괄호가 옵니다
(<code class="prettyprint lang-java">{}</code>)
.</p>

<p>예시:</p>

<pre class="prettyprint lang-java">  // This is acceptable
  void doNothing() {}

  // This is equally acceptable
  void doNothingElse() {
  }
</pre>
<pre class="prettyprint lang-java badcode">  // This is not acceptable: No concise empty blocks in a multi-block statement
  try {
    doSomething();
  } catch (Exception e) {}
</pre>

<h3 id="s4.2-block-indentation">4.2 블럭 들여쓰기: +2 칸</h3>

<p>매번 새 블럭이나 블럭같은 구조가 열릴 때, 들여쓰기는 2 칸씩 증가합니다. 블럭이 끝날 때, 들여쓰기는 이전 수준으로 돌아옵니다. 들여쓰기 수준은 코드와 주석 모두 블럭 안에서 계속 적용합니다. (Section 4.1.2의 예시를 보세요,
<a href="#s4.1.2-blocks-k-r-style">Nonempty blocks: K &amp; R Style</a>.)</p>

<h3 id="s4.3-one-statement-per-line">4.3 라인당 하나의 문(statement)</h3>

<p>각 문(statement)는 개행 뒤에 옵니다.</p>

<a name="columnlimit"></a>
<h3 id="s4.4-column-limit">4.4 행 제한: 100</h3>

<p>자바 코드는 100문자로 행을 제한합니다. "문자"는 임의의 유니코드 코드 
포인트를 의미합니다. 아래의 경우를 제외하고, 제한을 초과할 수 있는 경우 
Section 4.5, <a href="#s4.5-line-wrapping">Line-wrapping</a>에서 설명한 대로 
line-wrap 돼야 합니다.
</p>

<p class="tip">각 유니코드 코드 포인트는 실제 표시되는 너비가 더 크거나 
작더라도 하나의 문자로 셉니다. 예를 들어, <a href="https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms">전폭 문자</a>를 사용하는 경우, 이 규칙이 적용되는 곳에서보다 먼저 개행할 수 있습니다.</p>

<p><strong>예외:</strong></p>

<ol>
  <li>행 제한을 따르는 것이 불가한 줄(예를 들어, Javadoc의 긴 URL,
  혹은 긴 JSNI 메서드 레퍼런스).</li>

  <li><code class="prettyprint lang-java">package</code> 와
  <code class="prettyprint lang-java">import</code>문 (Sections
  3.2 <a href="#s3.2-package-statement">Package문</a> 와
  3.3 <a href="#s3.3-import-statements">Import문</a>을 보세요).</li>

  <li>주석에서, 쉘에 복사-붙여넣기 될 수 있는 커맨드라인.</li>
</ol>

<h3 id="s4.5-line-wrapping">4.5 Line-wrapping</h3>

<p class="terminology"><strong>용어 노트:</strong> 한 줄만 차지할 수 없는 
코드를 여러 줄로 나눌 때, 이를 <em>line-wrapping</em>이라고 부릅니다.</p>

<p>모든 상황에서 line-wrapping을 어떻게 하는지 <em>정확히</em> 보여줄 수 있는 
포괄적이고 결정적인 공식은 없습니다. 때때로 같은 코드 조각을 line-wrap 하는 몇 
가지 방법은 있습니다.</p>

<p class="note"><strong>Note:</strong> line-wrapping은 일반적으로 행 제한의 
초과를 피하기 위해 사용하지만, 행 제한을 넘지 않는 코드도 작성자의 재량에 따라 
wrap<em>될 수</em> 있습니다.</p>

<p class="tip"><strong>팁:</strong> 메서드나 지역 변수를 뽑아내는 것이 
line-wrap할 필요 없이 문제를 해결할 수도 있습니다.</p>

<h4 id="s4.5.1-line-wrapping-where-to-break">4.5.1 개행 위치</h4>

<p>line-wrapping의 가장 중요한 점은 
<strong>더 높은 구문 레벨</strong>에서 개행하는 것을 선호한다는 것입니다. 
또한:</p>

<ol>
  <li>줄이 <em>대입이 아닌</em> 연산자에서 개행되는 경우 기호 <em>앞에서</em> 
  개행이 이뤄집니다. (이는 C++와 Javascript와 같은 다른 언어의 Google 스타일과 동일한 관례가 아니라는 점을 알아두시기 바랍니다)
    <ul>
      <li>이는 다음의 "연산자 같은" 기호에도 적용합니다:
        <ul>
          <li>점 구분자 (<code class="prettyprint lang-java">.</code>)</li>
          <li>메서드 참조의 콜론 두 개
          (<code class="prettyprint lang-java">::</code>)</li>
          <li>타입 경계의 앰퍼샌드
          (<code class="prettyprint lang-java">&lt;T extends Foo &amp; Bar&gt;</code>)</li>
          <li>catch 블럭의 파이프
          (<code class="prettyprint lang-java">catch (FooException | BarException e)</code>).</li>
        </ul>
      </li>
    </ul>
  </li>

  <li>줄이 When a line is broken at an <em>대입</em> 연산자에서 개행되는 경우
  보통 기호 <em>다음에</em> 개행이 이뤄지지만, 두 방법 모두 사용 가능합니다.
    <ul>
      <li>이는 개선된 
      <code class="prettyprint lang-java">for</code> ("foreach")문의 "대입 연산자 같은" 콜론에도 적용합니다..</li>
    </ul>
  </li>

  <li>메서드나 생성자 이름은 여는 괄호
  (<code class="prettyprint lang-java">(</code>) 와 붙어있도록 합니다.</li>

  <li>쉼표 (<code class="prettyprint lang-java">,</code>)는 앞서는 토큰과 붙어있도록 합니다.</li>

  <li>람다의 내용이 괄호 없는 단일 식(expression)이어서 화살표 직후에 개행하는 경우를 제외하고, 람다의 화살표 근처에서는 절대 개행하지 않습니다. 예시:
<pre class="prettyprint lang-java">MyLambda&lt;String, Long, Object&gt; lambda =
    (String label, Long value, Object obj) -&gt; {
        ...
    };

Predicate&lt;String&gt; predicate = str -&gt;
    longExpressionInvolving(str);
</pre>
  </li>
</ol>

<p class="note"><strong>Note:</strong> line wrapping의 주 목적은 
<em>불필요하게</em> 최소한의 라인에 코드를 맞추는 것이 아니라 코드를 깔끔하게 
하는 데에 있습니다.</p>

<a name="indentation"></a>
<h4 id="s4.5.2-line-wrapping-indent">4.5.2 계속되는 행에는 최소한 4 칸 들여쓸 
것</h4>

<p>line wrapping할 때, 첫 번째 이후의 각 라인(각각 <em>계속되는 라인</em>)은 원래 라인으로부터 최소한 4 칸씩 들여씁니다.</p>

<p>계속되는 라인이 여럿인 경우, 필요에 따라 들여쓰기는 4 칸 이상이 될 수도 있습니다. 일반적으로, 두 개의 계속되는 라인이 문법적으로 평행한 요소로 시작한다면, 동일한 들여쓰기 수준을 사용합니다.</p>

<p>Section 4.6.3 <a href="#s4.6.3-horizontal-alignment">수평 정렬</a>에서 
특정 토큰을 이전 라인과 맞추기 위하여 가변적인 공백을 사용하는 관례에 대해 
다룹니다.</p>

<h3 id="s4.6-whitespace">4.6 공백</h3>

<h4 id="s4.6.1-vertical-whitespace">4.6.1 수직 공백</h4>

<p>빈 줄 하나는 다음과 같은 경우에 사용합니다:</p>

<ol>
  <li>필드, 생성자, 메서드, 중첩 클래스, 정적 초기자, 인스턴스 초기자와 같이 클래스의 멤버 혹은 초기자가 <em>연속</em>되는 경우.
  <ul>
    <li><span class="exception"><strong>예외:</strong> 연이은 두 필드 사이에( 다른 코드 없이도) 선택적으로 빈 줄을 삽입할 수 있습니다. 이러한 빈 줄은 필드들의 <em>논리적 그룹</em>을 만드는 데에 사용될 수 있습니다.</span></li>
    <li><span class="exception"><strong>예외:</strong> 열거 상수(enum constants) 사이의 빈 줄에 대해서는 <a href="#s4.8.1-enum-classes">Section 4.8.1</a>에서 다룹니다.</span></li>
  </ul>
  </li>

  <li>본 문서의 다른 영역에서 요구되는 경우(Section 3,
  <a href="#s3-source-file-structure">소스 파일 구조</a>, 그리고 Section 3.3,
  <a href="#s3.3-import-statements">Import문</a> 등).</li>
</ol>

<p>예를 들어 두 개의 문(statement) 사이에 코드의 논리적인 세부사항을 정리하기 
위한 경우 처럼, 하나의 빈 줄은 가독성을 높이기 위해 어디서든 나타날 수 
있습니다. 클래스의 첫 번째 멤버나 초기자 앞에 혹은 마지막 멤버나 초기자 뒤에 빈 
줄을 삽입하는 것은 권장하는 것은 아니지만 금지하는 것도 아닙니다.

</p><p><em>복수의</em> 연속된 빈 줄도 허용되지만, 필수(혹은 권장)는 아닙니다.</p>

<h4 id="s4.6.2-horizontal-whitespace">4.6.2 수평 공백</h4>

<p>언어 또는 다른 스타일 규칙에 의해 요구되는 경우를 넘어서, 문자, 주석 및 
Javadoc을 제외한 하나의 ASCII공간도 다음 위치에<strong>만</strong> 
나타납니다.</p>

<ol>
  <li>행에 이어지는 열린 괄호(<code class="prettyprint lang-java">(</code>)와
  <code class="prettyprint lang-java">if</code>,
  <code class="prettyprint lang-java">for</code> 혹은
  <code class="prettyprint lang-java">catch</code>와 같은 예약어의 구분.</li>

  <li>행의 앞에 있는 닫는 중괄호(<code class="prettyprint lang-java">}</code>)와 
  <code class="prettyprint lang-java">else</code> 혹은
  <code class="prettyprint lang-java">catch</code> 와 같은 예약어의 구분.</li>

  <li>여는 중괄호(<code class="prettyprint lang-java">{</code>)에 대해서는 다음의 예외를 적용합니다:
  <ul>
    <li><code class="prettyprint lang-java">@SomeAnnotation({a, b})</code> (no space is used)</li>

    <li><code class="prettyprint lang-java">String[][] x = {{"foo"}};</code> (no space is required
    between <code class="prettyprint lang-java">{{</code>, by item 8 below)</li>
  </ul>
  </li>

  <li>이항 또는 삼항 연산자의 양 쪽. 또한 이는 다음과 같은 "연산자 같은" 기호에도 적용합니다:
  <ul>
    <li>결합 타입 경계의 앰퍼샌드:
    <code class="prettyprint lang-java">&lt;T extends Foo &amp; Bar&gt;</code></li>

    <li>여러 예외를 처리하는 catch 블럭의 파이프:
    <code class="prettyprint lang-java">catch (FooException | BarException e)</code></li>

    <li>개선된 <code class="prettyprint lang-java">for</code> ("foreach")문의
    콜론 (<code class="prettyprint lang-java">:</code>)
    </li>

    <li>람다식의 화살표:
    <code class="prettyprint lang-java">(String str) -&gt; str.length()</code></li>
  </ul>
    다만, 다음의 경우는 사용하지 않습니다

  <ul>
    <li><code class="prettyprint lang-java">Object::toString</code>와 같은
    메서드 참조의 콜론 두 개 (<code class="prettyprint lang-java">::</code>.
  </li>
    <li><code class="prettyprint lang-java">object.toString()</code>와 같은 점 구분자(<code class="prettyprint lang-java">.</code>).
    </li>
  </ul>
  </li>

  <li><code class="prettyprint lang-java">,:;</code> 혹은 캐스팅의 닫는 괄호
  (<code class="prettyprint lang-java">)</code>)의 뒤</li>

  <li>주석이 시작되는 더블 슬래시(<code class="prettyprint lang-java">//</code>
  의 양 쪽. 이곳에는 복수의 공백이 허용됩니다만, 필수는 아닙니다.</li>

  <li>선언에서 타입과 변수의 사이:
  <code class="prettyprint lang-java">List&lt;String&gt; list</code></li>

  <li><em>선택적으로</em> 배열 초기자의 양 대괄호 바로 안쪽
  <ul>
    <li><code class="prettyprint lang-java">new int[] {5, 6}</code> and
    <code class="prettyprint lang-java">new int[] { 5, 6 }</code> are both valid</li>
  </ul>
  </li>

  <li>타입 어노테이션과 <code class="prettyprint lang-java">[]</code> 혹은
  <code class="prettyprint lang-java">...</code>의 사이.</li>
</ol>

<p>이 규칙은 절대 행의 시작이나 끝에 공백을 추가하는 것을 요구하거나 금지하는 것으로 해석될 수 없습니다. 오직 <em>내부</em> 공백에 대해서만 다룹니다.</p>

<h4 id="s4.6.3-horizontal-alignment">4.6.3 수평 정렬: 불필요</h4>

<p class="terminology"><strong>용어 노트:</strong> <em>수평 정렬</em>은 특정 토큰이 이전 라인의 다른 특정 토큰의 바로 아래에 위치하도록 코드에 몇 개의 공백을 추가하는 관례입니다.</p>

<p>이 관례는 허용되지만 구글 스타일에서 <strong>절대 필수는 아닙니다</strong>. 이미 수평 정렬이 사용된 곳에서 이를 <em>유지</em>할 필요도 없습니다.</p>

<p>정렬이 사용하지 않는 경우와, 사용하는 경우에 대한 예시입니다:</p>

<pre class="prettyprint lang-java">private int x; // this is fine
private Color color; // this too

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned
</pre>

<p class="tip"><strong>팁:</strong> 정렬은 가독성 향상에 도움이 될 수 있지만, 
이후에 유지보수에서 문제를 만듭니다. 미래에 한 라인을 수정해야 하는 경우가 
생기는 경우를 생각해 보십시오. 이 변경이 이전에 만들어진 형식을 손상시킬 수 
있는데, 이것이 허용됩니다. 이는 종종 코드 작성자(아마도 여러분)가 주변 라인의 
공백 또한 조정하도록 만듭니다, 어쩌면 이로 인해 다른 코드를 수정해야 하는 
상황이 연이어 발생할 수도 있습니다. 이 한 줄의 변경이 이젠 "폭발 반경"을 갖게 
되는 것입니다. 이는 최악의 경우 무의미한 업무를 만들 수 있지만, 기껏해야 버전 
히스토리 손상, 코드 리뷰 지체와 코드 병합 충돌(merge confilict)을 악화시키는 
정도로 끝날 수도 있습니다.</p>

<a name="parentheses"></a>
<h3 id="s4.7-grouping-parentheses">4.7 Grouping parentheses: recommended</h3>

<p>Optional grouping parentheses are omitted only when author and reviewer agree that there is no
reasonable chance the code will be misinterpreted without them, nor would they have made the code
easier to read. It is <em>not</em> reasonable to assume that every reader has the entire Java
operator precedence table memorized.</p>

<h3 id="s4.8-specific-constructs">4.8 Specific constructs</h3>

<h4 id="s4.8.1-enum-classes">4.8.1 Enum classes</h4>

<p>After each comma that follows an enum constant, a line break is optional. Additional blank
lines (usually just one) are also allowed. This is one possibility:

</p><pre class="prettyprint lang-java">private enum Answer {
  YES {
    @Override public String toString() {
      return "yes";
    }
  },

  NO,
  MAYBE
}
</pre>

<p>An enum class with no methods and no documentation on its constants may optionally be formatted
as if it were an array initializer (see Section 4.8.3.1 on
<a href="#s4.8.3.1-array-initializers">array initializers</a>).</p>

<pre class="prettyprint lang-java">private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
</pre>

<p>Since enum classes <em>are classes</em>, all other rules for formatting classes apply.</p>

<a name="localvariables"></a>
<h4 id="s4.8.2-variable-declarations">4.8.2 Variable declarations</h4>

<h5 id="s4.8.2.1-variables-per-declaration">4.8.2.1 One variable per declaration</h5>

<p>Every variable declaration (field or local) declares only one variable: declarations such as
<code class="badcode">int a, b;</code> are not used.</p>

<p><strong>Exception:</strong> Multiple variable declarations are acceptable in the header of a
<code class="prettyprint lang-java">for</code> loop.</p>

<h5 id="s4.8.2.2-variables-limited-scope">4.8.2.2 Declared when needed</h5>

<p>Local variables are <strong>not</strong> habitually declared at the start of their containing
block or block-like construct. Instead, local variables are declared close to the point they are
first used (within reason), to minimize their scope. Local variable declarations typically have
initializers, or are initialized immediately after declaration.</p>

<h4 id="s4.8.3-arrays">4.8.3 Arrays</h4>

<h5 id="s4.8.3.1-array-initializers">4.8.3.1 Array initializers: can be "block-like"</h5>

<p>Any array initializer may <em>optionally</em> be formatted as if it were a "block-like
construct." For example, the following are all valid (<strong>not</strong> an exhaustive
list):</p>

<pre class="prettyprint lang-java">new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
</pre>

<h5 id="s4.8.3.2-array-declarations">4.8.3.2 No C-style array declarations</h5>

<p>The square brackets form a part of the <em>type</em>, not the variable:
<code class="prettyprint lang-java">String[] args</code>, not
<code class="badcode">String args[]</code>.</p>

<h4 id="s4.8.4-switch">4.8.4 Switch statements</h4>



<p class="terminology"><strong>Terminology Note:</strong> Inside the braces of a
<em>switch block</em> are one or more <em>statement groups</em>. Each statement group consists of
one or more <em>switch labels</em> (either <code class="prettyprint lang-java">case FOO:</code> or
<code class="prettyprint lang-java">default:</code>), followed by one or more statements (or, for
the <em>last</em> statement group, <em>zero</em> or more statements).</p>

<h5 id="s4.8.4.1-switch-indentation">4.8.4.1 Indentation</h5>

<p>As with any other block, the contents of a switch block are indented +2.</p>

<p>After a switch label, there is a line break, and the indentation level is increased +2, exactly
as if a block were being opened. The following switch label returns to the previous indentation
level, as if a block had been closed.</p>

<a name="fallthrough"></a>
<h5 id="s4.8.4.2-switch-fall-through">4.8.4.2 Fall-through: commented</h5>

<p>Within a switch block, each statement group either terminates abruptly (with a
<code class="prettyprint lang-java">break</code>,
<code class="prettyprint lang-java">continue</code>,
<code class="prettyprint lang-java">return</code> or thrown exception), or is marked with a comment
to indicate that execution will or <em>might</em> continue into the next statement group. Any
comment that communicates the idea of fall-through is sufficient (typically
<code class="prettyprint lang-java">// fall through</code>). This special comment is not required in
the last statement group of the switch block. Example:</p>

<pre class="prettyprint lang-java">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</pre>

<p>Notice that no comment is needed after <code class="prettyprint lang-java">case 1:</code>, only
at the end of the statement group.</p>

<h5 id="s4.8.4.3-switch-default">4.8.4.3 The <code>default</code> case is present</h5>

<p>Each switch statement includes a <code class="prettyprint lang-java">default</code> statement
group, even if it contains no code.</p>

<p><strong>Exception:</strong> A switch statement for an <code>enum</code> type <em>may</em> omit
the <code class="prettyprint lang-java">default</code> statement group, <em>if</em> it includes
explicit cases covering <em>all</em> possible values of that type. This enables IDEs or other static
analysis tools to issue a warning if any cases were missed.

</p>

<a name="annotations"></a>
<h4 id="s4.8.5-annotations">4.8.5 Annotations</h4>

<p>Annotations applying to a class, method or constructor appear immediately after the
documentation block, and each annotation is listed on a line of its own (that is, one annotation
per line). These line breaks do not constitute line-wrapping (Section
4.5, <a href="#s4.5-line-wrapping">Line-wrapping</a>), so the indentation level is not
increased. Example:</p>

<pre class="prettyprint lang-java">@Override
@Nullable
public String getNameIfPresent() { ... }
</pre>

<p class="exception"><strong>Exception:</strong> A <em>single</em> parameterless annotation
<em>may</em> instead appear together with the first line of the signature, for example:</p>

<pre class="prettyprint lang-java">@Override public int hashCode() { ... }
</pre>

<p>Annotations applying to a field also appear immediately after the documentation block, but in
this case, <em>multiple</em> annotations (possibly parameterized) may be listed on the same line;
for example:</p>

<pre class="prettyprint lang-java">@Partial @Mock DataLoader loader;
</pre>

<p>There are no specific rules for formatting annotations on parameters, local variables, or types.
</p>

<a name="comments"></a>
<h4 id="s4.8.6-comments">4.8.6 Comments</h4>

<p>This section addresses <em>implementation comments</em>. Javadoc is addressed separately in
Section 7, <a href="#s7-javadoc">Javadoc</a>.</p>

<p>Any line break may be preceded by arbitrary whitespace followed by an implementation comment.
Such a comment renders the line non-blank.</p>

<h5 id="s4.8.6.1-block-comment-style">4.8.6.1 Block comment style</h5>

<p>Block comments are indented at the same level as the surrounding code. They may be in
<code class="prettyprint lang-java">/* ... */</code> style or
<code class="prettyprint lang-java">// ...</code> style. For multi-line
<code class="prettyprint lang-java">/* ... */</code> comments, subsequent lines must start with
<code>*</code> aligned with the <code>*</code> on the previous line.</p>

<pre class="prettyprint lang-java">/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */
</pre>


<p>Comments are not enclosed in boxes drawn with asterisks or other characters.</p>

<p class="tip"><strong>Tip:</strong> When writing multi-line comments, use the
<code class="prettyprint lang-java">/* ... */</code> style if you want automatic code formatters to
re-wrap the lines when necessary (paragraph-style). Most formatters don't re-wrap lines in
<code class="prettyprint lang-java">// ...</code> style comment blocks.</p>

 

<a name="modifiers"></a>
<h4 id="s4.8.7-modifiers">4.8.7 Modifiers</h4>

<p>Class and member modifiers, when present, appear in the order
recommended by the Java Language Specification:
</p>

<pre>public protected private abstract default static final transient volatile synchronized native strictfp
</pre>

<h4 id="s4.8.8-numeric-literals">4.8.8 Numeric Literals</h4>

<p><code>long</code>-valued integer literals use an uppercase <code>L</code> suffix, never
lowercase (to avoid confusion with the digit <code>1</code>). For example, <code>3000000000L</code>
rather than <code class="badcode">3000000000l</code>.</p>

<a name="naming"></a>
<h2 id="s5-naming">5 Naming</h2>

<h3 id="s5.1-identifier-names">5.1 Rules common to all identifiers</h3>

<p>Identifiers use only ASCII letters and digits, and, in a small number of cases noted below,
underscores. Thus each valid identifier name is matched by the regular expression
<code>\w+</code> .</p>

<p>In Google Style, special prefixes or suffixes are <strong>not</strong> used. For example, these
names are not Google Style: <code class="badcode">name_</code>, <code class="badcode">mName</code>,
<code class="badcode">s_name</code> and <code class="badcode">kName</code>.</p>

<h3 id="s5.2-specific-identifier-names">5.2 Rules by identifier type</h3>

<h4 id="s5.2.1-package-names">5.2.1 Package names</h4>

<p>Package names are all lowercase, with consecutive words simply concatenated together (no
underscores). For example, <code>com.example.deepspace</code>, not
<code class="badcode">com.example.deepSpace</code> or
<code class="badcode">com.example.deep_space</code>.</p>

<h4 id="s5.2.2-class-names">5.2.2 Class names</h4>

<p>Class names are written in <a href="#s5.3-camel-case">UpperCamelCase</a>.</p>

<p>Class names are typically nouns or noun phrases. For example,
<code class="prettyprint lang-java">Character</code> or
<code class="prettyprint lang-java">ImmutableList</code>. Interface names may also be nouns or
noun phrases (for example, <code class="prettyprint lang-java">List</code>), but may sometimes be
adjectives or adjective phrases instead (for example,
<code class="prettyprint lang-java">Readable</code>).</p>

<p>There are no specific rules or even well-established conventions for naming annotation types.</p>

<p><em>Test</em> classes are named starting with the name of the class they are testing, and ending
with <code class="prettyprint lang-java">Test</code>. For example,
<code class="prettyprint lang-java">HashTest</code> or
<code class="prettyprint lang-java">HashIntegrationTest</code>.</p>

<h4 id="s5.2.3-method-names">5.2.3 Method names</h4>

<p>Method names are written in <a href="#s5.3-camel-case">lowerCamelCase</a>.</p>

<p>Method names are typically verbs or verb phrases. For example,
<code class="prettyprint lang-java">sendMessage</code> or
<code class="prettyprint lang-java">stop</code>.</p>

<p>Underscores may appear in JUnit <em>test</em> method names to separate logical components of the
name, with <em>each</em> component written in <a href="#s5.3-camel-case">lowerCamelCase</a>.
One typical pattern is <code><i>&lt;methodUnderTest&gt;</i>_<i>&lt;state&gt;</i></code>,
for example <code class="prettyprint lang-java">pop_emptyStack</code>. There is no One Correct
Way to name test methods.</p>

<a name="constants"></a>
<h4 id="s5.2.4-constant-names">5.2.4 Constant names</h4>

<p>Constant names use <code class="prettyprint lang-java">CONSTANT_CASE</code>: all uppercase
letters, with each word separated from the next by a single underscore. But what <em>is</em> a
constant, exactly?</p>

<p>Constants are static final fields whose contents are deeply immutable and whose methods have no
detectable side effects. This includes primitives, Strings, immutable types, and immutable
collections of immutable types. If any of the instance's observable state can change, it is not a
constant. Merely <em>intending</em> to never mutate the object is not enough. Examples:</p>

<pre class="prettyprint lang-java">// Constants
static final int NUMBER = 5;
static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");
static final ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of("Ed", 35, "Ann", 32);
static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// Not constants
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();
static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);
static final ImmutableMap&lt;String, SomeMutableType&gt; mutableValues =
    ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
</pre>

<p>These names are typically nouns or noun phrases.</p>

<h4 id="s5.2.5-non-constant-field-names">5.2.5 Non-constant field names</h4>

<p>Non-constant field names (static or otherwise) are written
in <a href="#s5.3-camel-case">lowerCamelCase</a>.</p>

<p>These names are typically nouns or noun phrases.  For example,
<code class="prettyprint lang-java">computedValues</code> or
<code class="prettyprint lang-java">index</code>.</p>

<h4 id="s5.2.6-parameter-names">5.2.6 Parameter names</h4>

<p>Parameter names are written in <a href="#s5.3-camel-case">lowerCamelCase</a>.</p>

<p>One-character parameter names in public methods should be avoided.</p>

<h4 id="s5.2.7-local-variable-names">5.2.7 Local variable names</h4>

<p>Local variable names are written in <a href="#s5.3-camel-case">lowerCamelCase</a>.</p>

<p>Even when final and immutable, local variables are not considered to be constants, and should not
be styled as constants.</p>

<h4 id="s5.2.8-type-variable-names">5.2.8 Type variable names</h4>

<p>Each type variable is named in one of two styles:</p>

<ul>
  <li>A single capital letter, optionally followed by a single numeral (such as
  <code class="prettyprint lang-java">E</code>, <code class="prettyprint lang-java">T</code>,
  <code class="prettyprint lang-java">X</code>, <code class="prettyprint lang-java">T2</code>)
  </li>

  <li>A name in the form used for classes (see Section 5.2.2,
  <a href="#s5.2.2-class-names">Class names</a>), followed by the capital letter
  <code class="prettyprint lang-java">T</code> (examples:
  <code class="prettyprint lang-java">RequestT</code>,
  <code class="prettyprint lang-java">FooBarT</code>).</li>
</ul>

<a name="acronyms"></a>
<a name="camelcase"></a>
<h3 id="s5.3-camel-case">5.3 Camel case: defined</h3>

<p>Sometimes there is more than one reasonable way to convert an English phrase into camel case,
such as when acronyms or unusual constructs like "IPv6" or "iOS" are present. To improve
predictability, Google Style specifies the following (nearly) deterministic scheme.</p>

<p>Beginning with the prose form of the name:</p>

<ol>
  <li>Convert the phrase to plain ASCII and remove any apostrophes. For example, "M&#252;ller's
  algorithm" might become "Muellers algorithm".</li>

  <li>Divide this result into words, splitting on spaces and any remaining punctuation (typically
  hyphens).

  <ul>
    <li><em>Recommended:</em> if any word already has a conventional camel-case appearance in common
    usage, split this into its constituent parts (e.g., "AdWords" becomes "ad&#160;words"). Note
    that a word such as "iOS" is not really in camel case <em>per se</em>; it defies <em>any</em>
    convention, so this recommendation does not apply.</li>
  </ul>
  </li>

  <li>Now lowercase <em>everything</em> (including acronyms), then uppercase only the first
  character of:
  <ul>
    <li>... each word, to yield <em>upper camel case</em>, or</li>
    <li>... each word except the first, to yield <em>lower camel case</em></li>
  </ul>
  </li>

  <li>Finally, join all the words into a single identifier.</li>
</ol>

<p>Note that the casing of the original words is almost entirely disregarded. Examples:</p>

<table>
  <tbody><tr>
    <th>Prose form</th>
    <th>Correct</th>
    <th>Incorrect</th>
  </tr>
  <tr>
    <td>"XML HTTP request"</td>
    <td><code class="prettyprint lang-java">XmlHttpRequest</code></td>
    <td><code class="badcode">XMLHTTPRequest</code></td>
  </tr>
  <tr>
    <td>"new customer ID"</td>
    <td><code class="prettyprint lang-java">newCustomerId</code></td>
    <td><code class="badcode">newCustomerID</code></td>
  </tr>
  <tr>
    <td>"inner stopwatch"</td>
    <td><code class="prettyprint lang-java">innerStopwatch</code></td>
    <td><code class="badcode">innerStopWatch</code></td>
  </tr>
  <tr>
    <td>"supports IPv6 on iOS?"</td>
    <td><code class="prettyprint lang-java">supportsIpv6OnIos</code></td>
    <td><code class="badcode">supportsIPv6OnIOS</code></td>
  </tr>
  <tr>
    <td>"YouTube importer"</td>
    <td><code class="prettyprint lang-java">YouTubeImporter</code><br>
        <code class="prettyprint lang-java">YoutubeImporter</code>*</td>
    <td></td>
  </tr>
</tbody></table>

<p>*Acceptable, but not recommended.</p>

<p class="note"><strong>Note:</strong> Some words are ambiguously hyphenated in the English
language: for example "nonempty" and "non-empty" are both correct, so the method names
<code class="prettyprint lang-java">checkNonempty</code> and
<code class="prettyprint lang-java">checkNonEmpty</code> are likewise both correct.</p>


<h2 id="s6-programming-practices">6 Programming Practices</h2>

<h3 id="s6.1-override-annotation">6.1 <code>@Override</code>: always used</h3>

<p>A method is marked with the <code class="prettyprint lang-java">@Override</code> annotation
whenever it is legal.  This includes a class method overriding a superclass method, a class method
implementing an interface method, and an interface method respecifying a superinterface
method.</p>

<p class="exception"><strong>Exception:</strong>
<code class="prettyprint lang-java">@Override</code> may be omitted when the parent method is
<code class="prettyprint lang-java">@Deprecated</code>.</p>

<a name="caughtexceptions"></a>
<h3 id="s6.2-caught-exceptions">6.2 Caught exceptions: not ignored</h3>

<p>Except as noted below, it is very rarely correct to do nothing in response to a caught
exception. (Typical responses are to log it, or if it is considered "impossible", rethrow it as an
<code class="prettyprint lang-java">AssertionError</code>.)</p>

<p>When it truly is appropriate to take no action whatsoever in a catch block, the reason this is
justified is explained in a comment.</p>

<pre class="prettyprint lang-java">try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</pre>

<p class="exception"><strong>Exception:</strong> In tests, a caught exception may be ignored
without comment <em>if</em> its name is or begins with <code class="prettyprint lang-java">expected</code>. The
following is a very common idiom for ensuring that the code under test <em>does</em> throw an
exception of the expected type, so a comment is unnecessary here.</p>

<pre class="prettyprint lang-java">try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
</pre>

<h3 id="s6.3-static-members">6.3 Static members: qualified using class</h3>

<p>When a reference to a static class member must be qualified, it is qualified with that class's
name, not with a reference or expression of that class's type.</p>

<pre class="prettyprint lang-java">Foo aFoo = ...;
Foo.aStaticMethod(); // good
<span class="badcode">aFoo.aStaticMethod();</span> // bad
<span class="badcode">somethingThatYieldsAFoo().aStaticMethod();</span> // very bad
</pre>

<a name="finalizers"></a>
<h3 id="s6.4-finalizers">6.4 Finalizers: not used</h3>

<p>It is <strong>extremely rare</strong> to override <code class="prettyprint
lang-java">Object.finalize</code>.</p>

<p class="tip"><strong>Tip:</strong> Don't do it. If you absolutely must, first read and understand


  <a href="http://books.google.com/books?isbn=8131726592"><em>Effective Java</em> Item 7,</a>

"Avoid Finalizers," very carefully, and <em>then</em> don't do it.</p>


<a name="javadoc"></a>
<h2 id="s7-javadoc">7 Javadoc</h2>



<h3 id="s7.1-javadoc-formatting">7.1 Formatting</h3>

<h4 id="s7.1.1-javadoc-multi-line">7.1.1 General form</h4>

<p>The <em>basic</em> formatting of Javadoc blocks is as seen in this example:</p>

<pre class="prettyprint lang-java">/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
</pre>

<p>... or in this single-line example:</p>

<pre class="prettyprint lang-java">/** An especially short bit of Javadoc. */
</pre>

<p>The basic form is always acceptable. The single-line form may be substituted when the entirety
of the Javadoc block (including comment markers) can fit on a single line. Note that this only
applies when there are no block tags such as <code>@return</code>.

</p><h4 id="s7.1.2-javadoc-paragraphs">7.1.2 Paragraphs</h4>

<p>One blank line&#8212;that is, a line containing only the aligned leading asterisk
(<code>*</code>)&#8212;appears between paragraphs, and before the group of block tags if
present. Each paragraph but the first has <code>&lt;p&gt;</code> immediately before the first word,
with no space after.</p>

<a name="s7.1.3-javadoc-at-clauses"></a>

<h4 id="s7.1.3-javadoc-block-tags">7.1.3 Block tags</h4>

<p>Any of the standard "block tags" that are used appear in the order <code>@param</code>,
<code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, and these four types never
appear with an empty description. When a block tag doesn't fit on a single line, continuation lines
are indented four (or more) spaces from the position of the <code>@</code>.
</p>

<h3 id="s7.2-summary-fragment">7.2 The summary fragment</h3>

<p>Each Javadoc block begins with a brief <strong>summary fragment</strong>. This
fragment is very important: it is the only part of the text that appears in certain contexts such as
class and method indexes.</p>

<p>This is a fragment&#8212;a noun phrase or verb phrase, not a complete sentence. It does
<strong>not</strong> begin with <code class="badcode">A {@code Foo} is a...</code>, or
<code class="badcode">This method returns...</code>, nor does it form a complete imperative sentence
like <code class="badcode">Save the record.</code>. However, the fragment is capitalized and
punctuated as if it were a complete sentence.</p>

<p class="tip"><strong>Tip:</strong> A common mistake is to write simple Javadoc in the form
<code class="badcode">/** @return the customer ID */</code>. This is incorrect, and should be
changed to <code class="prettyprint lang-java">/** Returns the customer ID. */</code>.</p>

<a name="s7.3.3-javadoc-optional"></a> 
<h3 id="s7.3-javadoc-where-required">7.3 Where Javadoc is used</h3>

<p>At the <em>minimum</em>, Javadoc is present for every
<code class="prettyprint lang-java">public</code> class, and every
<code class="prettyprint lang-java">public</code> or
<code class="prettyprint lang-java">protected</code> member of such a class, with a few exceptions
noted below.</p>

<p>Additional Javadoc content may also be present, as explained in Section 7.3.4,
<a href="#s7.3.4-javadoc-non-required">Non-required Javadoc</a>.</p>

<h4 id="s7.3.1-javadoc-exception-self-explanatory">7.3.1 Exception: self-explanatory methods</h4>

<p>Javadoc is optional for "simple, obvious" methods like
<code class="prettyprint lang-java">getFoo</code>, in cases where there <em>really and truly</em> is
nothing else worthwhile to say but "Returns the foo".</p>

<p class="note"><strong>Important:</strong> it is not appropriate to cite this exception to justify
omitting relevant information that a typical reader might need to know. For example, for a method
named <code class="prettyprint lang-java">getCanonicalName</code>, don't omit its documentation
(with the rationale that it would say only
<code class="badcode">/** Returns the canonical name. */</code>) if a typical reader may have no idea
what the term "canonical name" means!</p>

<h4 id="s7.3.2-javadoc-exception-overrides">7.3.2 Exception: overrides</h4>

<p>Javadoc is not always present on a method that overrides a supertype method.

</p>



<h4 id="s7.3.4-javadoc-non-required">7.3.4 Non-required Javadoc</h4>

<p>Other classes and members have Javadoc <em>as needed or desired</em>.

</p><p>Whenever an implementation comment would be used to define the overall purpose or behavior of a
class or member, that comment is written as Javadoc instead (using <code>/**</code>).</p>

<p>Non-required Javadoc is not strictly required to follow the formatting rules of Sections
7.1.2, 7.1.3, and 7.2, though it is of course recommended.</p>

 

</div> 
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>Google JavaScript Style Guide</title>
<link rel="stylesheet" href="javaguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico">
<script src="include/jsguide.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google JavaScript Style Guide</h1>
<h2 id="introduction">1 소개</h2>

<p>이 문서는 Javascript 프로그래밍 언어로 작성된 코드에 대한 구글의 코딩 표준의 <strong>완전한</strong> 정의 역할을 합니다. Javascript 소스 파일은 이 문서의 규칙을 따라야 <em>구글 스타일로</em>표시됩니다.</p>

<p>다른 프로그래밍 스타일 가이드처럼, 서식의 미적인 문제 뿐만 아니라, 다른 
유형이나 코딩 표준에 대한 문제도 다뤄집니다. 하지만, 이 문서는 우선적으로 범용적으로 따르는 명확한 규칙들에 집중하고, (직접 하든 도구를 사용하든) 명확하게 따를 수 없는 조언들은 피합니다. </p>

<h3 id="terminology-notes">1.1 용어 노트</h3>

<p>이 문서에서는 별도로 명시되지 않는 한, 다음을 따릅니다:</p>

<ol>
<li><p><em>주석</em>은 항상 <em>구현</em> 주석을 의미합니다. <q>문서화
주석</q>이라는 용어는 사용하지 않으며, 대신 <code>/** &#8230; */</code>안에
위치한 사람이 읽을 수 있는 문자와 기계가 읽을 수 있는 어노테이션에 대해
&#8220;JSDoc&#8221;을 공통 용어로 사용합니다. </p></li>
<li><p>이 스타일 가이드는 <em>해야 한다</em>, <em>해서는 안된다</em>, <em>하는 것이 좋다</em>, <em>하지 않는 것이 좋다</em>, 그리고 <em>할 수 있다</em>로 표기할 때에는 <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a>의 용어를 사용합니다. <em>선호한다</em>와 <em>피한다</em>는 각각 <em>하는 것이 좋다</em>와 <em>하지 않는 것이 좋다</em>에 대응합니다. 명령적이고 선언적인 구문들은 <em>해야 한다</em>에 대응합니다.</p></li>
</ol>

<p>다른 <q>용어 노트</q>가 가끔 문서 중간에 나타날 것입니다.</p>

<h3 id="guide-notes">1.2 가이드 노트</h3>

<p>이 문서의 예시 코드는 <strong>비표준</strong>입니다. 즉, 예시들이 구글 스타일이어도 그 코드를 대표하는 <em>유일하게</em> 우아한 방법을 설명하는 것이 아닐 수 있습니다. 예시에서 사용된 선택 사항의 서식은 규칙으로서 강요되서는 안됩니다.</p>

<h2 id="source-file-basics">2 소스 파일 기본</h2>

<h3 id="file-name">2.1 파일명</h3>

<p>파일명은 모두 소문자이며 언더스코어(<code>_</code>) 혹은 대시(<code>-</code>)
를 포함할 수도 있지만, 다른 구두점은 사용할 수 없습니다. 프로젝트에서 사용하는 관례를 따르십시오. 파일명의 확장자는 <code>.js</code>여야 합니다.</p>

<h3 id="file-encoding">2.2 파일 인코딩: UTF-8</h3>

<p>소스 파일은 <strong>UTF-8</strong>로 인코딩됩니다.</p>

<h3 id="special-characters">2.3 특수 문자</h3>

<h4 id="whitespace-characters">2.3.1 공백 문자</h4>

<p>라인 종걸 시퀀스를 제외하고, ASCII 수평 공백 문자(0x20)만이 소스 파일 어느 곳에서나 나타나는 유일한 공백 문자입니다. 이는 다음을 의미합니다</p>

<ol>
<li><p>문자열 리터럴에 있는 모든 공백 문자는 이스케이프 되며,</p></li>
<li><p>탭 문자는 들여쓰기에 사용하지 <strong>않습니다</strong>.</p></li>
</ol>

<h4 id="special-escape-sequences">2.3.2 특수 이스케이프 시퀀스</h4>

<p>특수 이스케이프 시퀀스 (<code>\'</code>, <code>\"</code>, <code>\\</code>,
<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>,
<code>\t</code>, <code>\v</code>)를 가진 임의의 문자에 대해, 그 시퀀스는 대응되는 숫자 이스케이프 대신 사용됩니다 (e.g <code>\x0a</code>, <code>\u000a</code>, 혹은 <code>\u{a}</code>). 기존의 8진수 이스케이프는 절대 사용되지 않습니다.</p>

<h4 id="non-ascii-characters">2.3.3 Non ASCII 문자</h4>

<p>Non ASCII 문자를 남겨두기 위해서는, 어느 쪽이 코드를 더
<strong>읽고 이해하기 쉽게</strong> 만드는지에 따라 실제 유니코드 문자
(e.g. <code>&#8734;</code>) 혹은 동등한 16진수나 유니코드 이스케이프
(e.g. <code>\u221e</code>)가 사용됩니다.</p>

<p>팁: 유니코드 이스케이프를 사용하는 경우와, 심지어 실제 유니코드 문자를 사용하는 경우에도, 이를 설명하는 주석은 매우 유용할 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>Example
      </th><th>Discussion
  </th></tr></thead><tbody>
    <tr>
      <td><code class="prettyprint lang-js">const units = '&#956;s';</code>
      </td><td>Best: 주석이 없어도 완벽하게 깔끔합니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // '&#956;s'
        </code>
      </td><td>허용되지만, 이렇게 할 이유는 없습니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // Greek letter mu, 's'
        </code>
      </td><td>허용되지만, 어색하고 실수할 여지가 있습니다.
    </td></tr><tr>
      <td><code class="badcode">const units = '\u03bcs';</code>
      </td><td>Poor: 읽는 사람은 뭔지 전혀 모릅니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">return '\ufeff' + content;  // byte order mark
        </code>
      </td><td>
        Good: 비 출력 문자를 위해 이스케이프를 사용하고, 필요한 경우 주석을 추가하십시오.
</td></tr></tbody></table>

<p>팁: 절대로 프로그램이 non ASCII 문자를 적절히 처리하지 못할 거라는 두려움 때문에 쉽게 코드의 가독성을 떨어뜨리지 마십시오. 만약 그런 일이 발생한다면, 그런 프로그램은 <strong>고장</strong>날 것이고, <strong>고쳐져</strong>야 합니다.</p>

<h2 id="source-file-structure">3 소스 파일 구조</h2>

<p>소스 파일은 다음 <strong>순서대로</strong> 구성됩니다:</p>

<ol>
<li>라이센스 혹은 저작권 정보(있는 경우)</li>
<li><code>@fileoverview</code> JSDoc(있는 경우)</li>
<li><code>goog.module</code>문</li>
<li><code>goog.require</code>문</li>
<li>파일의 구현부</li>
</ol>

<p>1개 혹은 2개의 빈 줄이 올 수 있는 파일의 구현부를 제외하고, <strong>정확히 하나의 빈 줄이</strong> 각 섹션을 구분합니다.</p>

<h3 id="file-copyright">3.1 라이센스 혹은 저작권 정보(있는 경우)</h3>

<p>파일에 라이센스 혹은 라이센스 정보가 들어가는 경우, 여기에 속합니다.</p>

<h3 id="file-fileoverview">3.2 <code>@fileoverview</code> JSDoc(있는 경우)</h3>

<p>서식 규칙에 대해서는 <a href="#jsdoc-top-file-level-comments">??</a>을 보시기 바랍니다.</p>

<h3 id="file-goog-module">3.3 <code>goog.module</code>문</h3>

<p>모든 파일은 한 줄에 정확히 하나의 <code>goog.module</code> 이름을 선언해야 합니다. <code>goog.module</code> 선언은 포장되선 안되며, 따라서 80자 제한에 예외로 합니다.</p>

<p>네임스페이스를 정의하는 것은 goog.module에 대한 전체 인자입니다. 이는 패키지 명(코드가 존재하는 디렉터리 구조의 조각을 반영한 식별자) + 선택적으로 패키지가 정의하는 메인 클래스/열거형/인터페이스를 끝에 연결합니다. The entire argument to goog.module is what defines a namespace.</p>

<p>예시</p>

<pre><code class="language-js prettyprint">goog.module('search.urlHistory.UrlHistoryService');
</code></pre>

<h4 id="naming-hierarchy">3.3.1 계층</h4>

<p>모듈 네임스페이스는 다른 모듈 네임스페이스의 <em>자식(direct child)</em>로 명명될 수 없습니다.</p>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">goog.module('foo.bar');   // 'foo.bar.qux' would be fine, though
goog.module('foo.bar.baz');
</code></pre>

<p>디렉터리 계층은 네임스페이스 계층을 반영하기 때문에, 더 깊게 중첩된 자식들은 더 높은 수준의 부모 디렉터리의 서브디렉터리입니다. &#8220;부모&#8221; 네임스페이스 그룹은 같은 디렉터리에 있게 된 순간부터 모든 자식 네임스페이스를 알고 있음을 의미한다는 것을 알아두십시오.</p>

<h4 id="file-set-test-only">3.3.2 <code>goog.setTestOnly</code></h4>

<p>하나의 <code>goog.module</code>문은 선택적으로 goog.setTestOnly() 호출에
따라올 수 있습니다.</p>

<h4 id="file-declare-legacy-namespace">3.3.3 <code>goog.module.declareLegacyNamespace</code></h4>

<p>하나의 <code>goog.module</code>문은
<code>goog.module.declareLegacyNamespace();</code> 호출에 따라올 수 있습니다.
가능하면<code>goog.module.declareLegacyNamespace()</code>은 피하십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();
</code></pre>

<p><code>goog.module.declareLegacyNamespace</code>은 기존의 객체 계층 기반 네임 스페이스로부터의 전환을 용이하게 하기 위해 존재하지만 몇 가지 명명에 제한이 있습니다. 자식 모듈 이름은 부모 네임스페이스 뒤에 생성되어야 하므로 이 이름은 <code>goog.module</code>의 하위 혹은 상위 이름이 될 수 없습니다(예를 들어, <code>goog.module('parent');</code> 와
<code>goog.module('parent.child');</code> 모두 안전하게 존재할 수 없으며,
<code>goog.module('parent');</code>와 <code>goog.module
('parent.child.grandchild');</code> 또한 마찬가지입니다).</p>

<h4 id="file-es6-modules">3.3.4 ES6 모듈</h4>

<p>의미가 아직 완전하지 않기 때문에, 아직은 (<code>export</code>와
<code>import</code> 키워드와 같은) ES6 모듈을 사용하지 마십시오. 의미가 완전히 표준이 되면 이 정책은 다시 한번 확인하시기 바랍니다.</p>

<h3 id="file-goog-require">3.4 <code>goog.require</code>문</h3>

<p>모듈 선언 직후 그룹화된 <code>goog.require</code>문으로
임포트를 수행합니다. 각 <code>goog.require</code>은 하나의 상수
볆명(alias)에 할당되거나, 여러 개의 상수 별칭으로 destructure
됩니다. 이러한 별칭은 코드는 타입 표기에서 <code>require</code>된
의존성을 참조할 수 있는 유일한 방법입니다. <code>goog.require</code>에 대한 인자를 제외하고 전체 이름은
사용되지 않습니다. 별칭 이름은 가능하면 임포트된 모듈의 마지막
점-구분 컴포넌트와 일치해야 합니다. 단, 차이를 분명히 구분해야
하거나 명확하게 가독성을 향상시키는 경우, 추가 컴포넌트가(올바르게
별칭의 타입을 구분하는 적절한 대소문자 구분으로) 포함될 수
있습니다. <code>goog.require</code>문은 이 파일 다른 곳에서는 등장하지 않을 수 있습니다.</p>

<p>만약 모듈이 부수 효과(side effect)만을 위해 임포트되었다면
할당이 생략될 수 있지만, 전체 이름이 파일의 다른 곳에 등장하지 않을 수 있습니다. 
주석은 이것이 왜 필요하고 컴파일러 경고를 무시해야 하는 지 설명하기 위해 필요합니다.</p>



<p>줄은 다음의 규칙에 따라 정렬됩니다. 왼쪽에 이름이 있는
(별칭에 할당되는) require가 첫 번째이며, 그 이름들에 따라 알파벳 순으로
정렬됩니다. 그 다음 destructure된 require가 다시 한번 왼쪽의 이름으로 정렬됩니다.
마지막으로, 임의의 단독 <code>goog.require</code> 호출이 위치합니다(일반적으로 이들은 오직 부수 효과만을 위해 임포트되는 모듈을 위한것입니다).</p>

<p>팁: 순서를 기억하고 정렬하는 일을 직접 할 필요는 없습니다. IDE가
올바르게 정렬되지 않은 require를 보고하도록 할 수 있습니다.</p>

<p>만약 긴 별칭 혹은 모듈 이름이 80자 제한을 초과한다면, 이는 포장되서는 <strong>안됩니다</strong>. goog.require 줄은 80자 제한에서 예외입니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">const MyClass = goog.require('some.package.MyClass');
const NsMyClass = goog.require('other.ns.MyClass');
const googAsserts = goog.require('goog.asserts');
const testingAsserts = goog.require('goog.testing.asserts');
const than80columns = goog.require('pretend.this.is.longer.than80columns');
const {clear, forEach, map} = goog.require('goog.array');
/** @suppress {extraRequire} Initializes MyFramework. */
goog.require('my.framework.initialization');
</code></pre>

<p>나쁜 예:</p>

<pre><code class="language-js badcode prettyprint">const randomName = goog.require('something.else'); // name must match

const {clear, forEach, map} = // don't break lines
    goog.require('goog.array');

function someFunction() {
  const alias = goog.require('my.long.name.alias'); // must be at top level
  // &#8230;
}
</code></pre>

<h4 id="file-goog-forward-declare">3.4.1 <code>goog.forwardDeclare</code></h4>

<p><code>goog.forwardDeclare</code>는 자주 필요하진 않지만 순환 의존석을 해제하거나 나중에 로드된 코드를 참조하는 데 유용한 도구입니다. 이러한 구문들은 그룹화되며 즉시 임의의 <code>goog.rquire</code>문을 따릅니다. <code>goog.forwardDeclare</code>문은 <code>goog.require</code>문과 동일한 스타일 규칙을 따릅니다.</p>

<h3 id="file-implementation">3.5 파일의 구현</h3>

<p>실질적인 구현은 모든 의존성 정보가 선언된 이후에 (적어도 하나의 빈 줄로 구분되어) 위치합니다.</p>

<p>이는 모듈-지역 선언(상수, 변수, 클래스, 함수, etc)에 더하여 임의의 익스포트 기호로 구성될 수 있습니다.</p>

<h2 id="formatting">4 서식</h2>

<p><strong>용어 노트</strong>: <em>유사 블럭 구조</em>는 클래스의 몸체, 함수, 메서드, 혹은 괄호로 구분된 코드 블럭을 나타냅니다. <a href="#features-array-literals">??</a>와 <a href="#features-object-literals">??</a>에 의해 임의의 배열 혹은 객체 리터럴이 선택적으로 유사 블럭 구조인 것 처럼 취급될 수 있습니다.</p>

<p>팁: <code>clang-format</code>(코드 자동 포맷팅 도구)을 사용하십시오. Javascript 커뮤니티는 clang-format이 Javascript 파일에서 <q>옳은 일을 하도록</q> 노력했습니다. <code>clang-format</code>은 몇몇 유명한 편집기와 통합됐습니다.</p>

<h3 id="formatting-braces">4.1 중괄호</h3>

<h4 id="formatting-braces-all">4.1.1 중괄호는 모든 제어 구조에 사용된다</h4>

<p>중괄호는 모든 제어 구조(i.e. <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> 등)에, 몸체가 단 한줄만을 포함하더라도 필요합니다. 비어 있지 않은 블럭의 첫 번째 문장(statement)는 새 줄에서 시작해야 합니다.</p>

<p>나쁜 예:</p>

<pre><code class="language-js badcode prettyprint">if (someVeryLongCondition())
  doSomething();

for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);
</code></pre>

<p><strong>예외</strong>: else가 없이, 포장되지 않은 채로 전체가 한 줄에
들어맞는 단순한 if문은 가독성을 높일 수 있는 경우 한 줄에 중괄호 없이 작성될 수
있습니다. 이는 제어 구조가 중괄호와 새 줄을 생략할 수 있는 유일한
경우입니다.</p>

<pre><code class="language-js prettyprint">if (shortCondition()) return;
</code></pre>

<h4 id="formatting-nonempty-blocks">4.1.2 비어있지 않은 블럭: K&amp;R 스타일</h4>

<p><em>비어있지 않은</em> 블럭과 유사 블럭 구조의 중괄호는 Kernighan and Ritchie 스타일(<q><a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a></q>)을 따릅니다:</p>

<ul>
<li>여는 중괄호 앞에서 개행하지 않습니다.</li>
<li>여는 중괄호 뒤에서 개행합니다.</li>
<li>닫는 중괄호 앞에서 개행합니다.</li>
<li><em>만약</em> 닫는 중괄호가 구문(statement) 혹은 함수나 클래스의 몸체 혹은
클래스 메서드 구문을 끝내는 경우 닫는 중괄호 뒤에서 개행합니다. 구체적으로,
<code>else</code>, <code>catch</code>, <code>while</code>, 혹은 쉽표, 세미콜론,
혹은 닫는 소괄호가 뒤에 따르는 경우, 개행하지 <em>않</em>습니다.</li>
</ul>

<p>예시:</p>

<pre><code class="language-js prettyprint">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code></pre>

<h4 id="formatting-empty-blocks">4.1.3 빈 블럭: 갈결할 수 있음</h4>

<p><em>다중 블럭 구문</em>(다중 블럭을 직접 포함하는 것: 
<code>if</code>/<code>else</code> 혹은
<code>try</code>/<code>catch</code>/<code>finally</code>)의 일부가
<em>아닌 이상</em>, 빈 블럭이나 유사 블럭 구조는 사이에 문자, 공백, 개행 없이
열린 즉시 닫힐 <em>수</em> 있습니다(즉, <code>{}</code>).</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">function doNothing() {}
</code></pre>

<p>나쁜 예:</p>

<pre><code class="language-js prettyprint badcode">if (condition) {
  // &#8230;
} else if (otherCondition) {} else {
  // &#8230;
}

try {
  // &#8230;
} catch (e) {}
</code></pre>

<h3 id="formatting-block-indentation">4.2 블럭 들여쓰기: +2 칸</h3>

<p>새 블럭 혹은 유사 블럭 구조가 열릴 때마다, 들여쓰기는 2칸 증가합니다.
블럭이 끝나면, 들여쓰기는 이전 들여쓰기 수준으로 돌아갑니다. 들여쓰기 수준은
블럭 내의 코드와 주석 양쪽에 적용합니다. (<a href="#formatting-nonempty-blocks">??</a>의 예시를 보세요).</p>

<h4 id="formatting-array-literals">4.2.1 배열 리터럴: 선택적으로 <q>유사 블럭 </q></h4>

<p>임의의 배열 리터럴은 &#8220;유사 블럭 구조&#8221;인 것 처럼 서식을 적용할 수 있습니다. 예를 들어, 다음은 모두 유효합니다(완전한 리스트는 <strong>아님</strong>):</p>

<pre><code class="language-js prettyprint columns">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code></pre>

<pre><code class="language-js prettyprint columns">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code></pre>

<p>특히 원소 간에 구문 그룹핑을 포함하여 다른 조합도 허용되지만, 단순히 큰 배열의 수직 크기를 줄이기 위해서 사용하지는 말아야 합니다.</p>

<h4 id="formatting-object-literals">4.2.2 객체 리터럴: 선택적으로 <q>유사 블럭</q></h4>

<p>임의의 객체 리터럴은 선택적으로 &#8220;유사 블럭 구조&#8221;인 것 처럼 서식을 적용할 수 있습니다. <a href="#formatting-array-literals">??</a>와 동일한 예시를 적용합니다. 예를 들어, 다음은 모두 유효합니다(완전한 리스트는 <strong>아님</strong>):</p>

<pre><code class="language-js prettyprint columns">const a = {
  a: 0,
  b: 1,
};

const b =
    {a: 0, b: 1};
</code></pre>

<pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code></pre>

<h4 id="formatting-class-literals">4.2.3 클래스 리터럴</h4>

<p>클래스 리터럴(선언이든 표현식이든)은 블럭으로써 들여쓰기됩니다. 메서드
끝이나 클래스 <em>선언</em>(할당(assignment)과 같이 클래스 <em>표현식</em>을
포함하는 구문은 여전히 세미콜론으로 끝납니다)의 닫는 중괄호에 세미콜론을
추가하지 마십시오. <code>extends</code> 키워드를 사용하되, 클래스가 템플릿화된 타입을 확장하는 것이 아니라면 <code>@extends</code> JSDoc 표기는 사용하지 마십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint columns">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
</code></pre>

<pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>

<h4 id="formatting-function-expressions">4.2.4 함수 표현식</h4>

<p>함수 호출의 인자 리스트에서 익명 함수를 선언할 때, 함수의 본문은 이전
들여쓰기 깊이보다 두 칸 더 들여쓰기됩니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) =&gt; {
      // Indent the function body +2 relative to the indentation depth
      // of the '.then()' call.
      if (result) {
        result.use();
      }
    });
</code></pre>

<h4 id="formatting-switch-statements">4.2.5 Switch문</h4>

<p>다른 블럭들과 마찬가지로, switch 블럭의 내용들은 +2 칸 들여쓰기됩니다.</p>



<p>switch 레이블 뒤에는 새 줄이 나타나며 블럭이 열릴 때 처럼 들여쓰기 수준은
2 칸 증가합니다. 렉시컬 스코핑에 필요한 경우 명시적인 블럭이 사용될 수
있습니다. 그 뒤에 따르는 switch 레이블은 블럭이 닫힐 때 처럼 이전 들여쓰기
수준으로 돌아갑니다.</p>

<p><code>break</code>와 그 다음 case 사이의 빈 줄은 선택사항입니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}
</code></pre>

<h3 id="formatting-statements">4.3 구문(statment)</h3>

<h4 id="formatting-one-statement-perline">4.3.1 한 줄에 한 구문 씩</h4>

<p>각 구문에는 개행이 뒤따릅니다.</p>

<h4 id="formatting-semicolons-are-required">4.3.2 세미콜론 필수</h4>

<p>모든 구문은 세미콜론으로 끝나야 합니다. 자동 세미콜론 삽입에 의존하는 것을 금합니다.</p>

<h3 id="formatting-column-limit">4.4 열 제한: 80자</h3>

<p>Javascript 코드는 80자의 열 제한을 갖습니다. 아래에 나열된 경우를 제외하고,
이를 초과하는 임의의 줄은 <a href="#formatting-line-wrapping">??</a>에 설명된
것 처럼 라인-포장되어야 합니다.</p>

<p><strong>예외:</strong></p>

<ol>
<li>열 제한을 따를 수 없는 라인 (예를 들어, JSDoc에서 복사-붙여넣기를 위한 긴 URL 혹은 쉘 명령).</li>
<li><code>goog.module</code>과 <code>goog.require</code> 구문 (<a href="#file-goog-module">??</a> 과
<a href="#file-goog-require">??</a> 참조).</li>
</ol>

<h3 id="formatting-line-wrapping">4.5 라인 포장</h3>

<p><strong>용어 노트</strong>: <em>줄 바꿈</em>은 하나의 표현식을 여러 줄로 나누는 것으로 정의됩니다.</p>

<p>매 상황에서의 줄 바꿈 방법을 <em>정확히</em> 보여주는 포괄적이고 결정적인 공식은 없습니다. 같은 코드 조각을 줄 바꿈하는 방법이 여러 가지인 경우가 매우 많습니다.</p>

<p>노트: 줄 바꿈을 사용하는 전형적인 이유는 열 제한을 초과하는 것을 피하기 위함이지만, 실제로 열 제한에 맞는 코드도 작성자의 재량에 따라 줄 바꿈될 수 있습니다.</p>

<p>팁: 메서드나 지역 변수를 추출해내는 것이 줄 바꿈할 필요 없이 문제를 해결할 수도 있습니다.</p>

<h4 id="formatting-where-to-break">4.5.1 개행 위치</h4>

<p>줄 바꿈의 주요 지시 사항은 <strong>더 높은 구문 수준</strong>에서 개행하는 것을 선호한다는 것입니다. </p>

<p>선호:</p>

<pre><code class="language-js prettyprint">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0f;
</code></pre>

<p>비선호:</p>

<pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0f;
</code></pre>

<p>앞선 예시에서, 가장 높은 구문 수준에서 가장 낮은 구문 수준은 다음과 같습니다: 할당, 나누기, 함수 호출, 매개변수, 숫자 상수.</p>

<p>연산자는 다음과 같이 래핑됩니다:</p>

<ol>
<li>줄이 연산자에서 바뀌는 경우 개행은 기호 다음에 옵니다. (이는 Java에 대한 Google 스타일과 다른 관례라는 점을 기억하십시오.)
<ol>
<li>이는 실질적으로 연산자가 아닌 <q>점</q>(<code>.</code>)에는 적용하지 않습니다.</li>
</ol></li>
<li>메서드 혹은 생성자 이름은 이에 따르는 여는 괄호(<code>(</code>)와 붙어 있습니다.</li>
<li>쉼표(<code>,</code>)는 이에 앞서는 토큰과 붙어 있습니다.</li>
</ol>

<blockquote>
<p>Note: 줄 바꿈의 우선 목표는 적은 줄에 불필요하게 코드를 맞추는 것이 아니라, 코드를 깔끔하게 하는 것입니다.</p>
</blockquote>

<h4 id="formatting-indent">4.5.2 이어지는 줄은 적어도 4 칸 들여쓸 것</h4>

<p>줄 바꿈시, 첫 번째 이후 각 줄(각 <em>이어지는 줄</em>)은 블럭 들여쓰기 규칙을 위반하지 않는 한, 처음 줄로부터 적어도 +4 칸 들여쓰기됩니다.</p>

<p>이어지는 줄이 여러 줄인 경우, 들여쓰기는 +4 칸 이상으로도 적절하게 변형될 수
있습니다. 일반적으로, 더 깊은 구문 수준에서 이어지는 줄은 4 칸보다 더
들여쓰기되며, 문법적으로 평행한(병렬적인) 원소로 시작하는 경우 두 줄은 같은
들여쓰기 수준을 사용합니다.</p>

<p><a href="#formatting-horizontal-alignment">??</a>은 특정 토큰을 이전 줄과 맞추기 위해 가변적인 수의 공백을 사용하는 좋지 않은 관례들을 다룹니다.</p>

<h3 id="formatting-whitespace">4.6 공백</h3>

<h4 id="formatting-vertical-whitespace">4.6.1 수직 공백</h4>

<p>하나의 빈 줄은 다음의 경우 나타납니다:</p>

<ol>
<li>연이은 메서드 혹은 객체 리터럴의 사이
<ol>
<li>예외: 객체 리터럴의 연이은 두 프로퍼티 사이(에 다른 코드 없이)의 빈 줄은 선택 사항입니다. 이러한 빈 줄은 필드의 <em>논리적 그룹</em>을 만드는 데 사용됩니다.</li>
</ol></li>
<li>메서드 본문에서, 구문의 논리적 그룹화를 위해.
함수 본문의 시작 혹은 끝의 빈 줄은 허용되지 않습니다.</li>
<li><em>선택적으로</em> 클래스 혹은 객체 리터럴에서 첫 메서드 앞이나 마지막 메서드의 뒤.</li>
<li>본 문서의 다른 섹션에서 요구되는 경우 (e.g.
<a href="#file-goog-require">??</a>).</li>
</ol>

<p><em>복수의</em> 연이은 빈 줄은 허용되지만 필수는 아닙니다.</p>

<h4 id="formatting-horizontal-whitespace">4.6.2 수평 공백</h4>

<p>수평 공백의 사용은 위치에 따라 다르며, 3개의 카테고리로 분류됩니다:
<em>앞서는 공백</em>(줄의 시작에), <em>따르는 공백</em>(줄의 끝에),
<em>내부 공백</em>. 앞서는 공백(i.e. 들여쓰기)은 다른 곳에서 다뤄집니다.
따르는 공백은 금지됩니다.</p>

<p>언어나 다른 스타일 규칙에 의해 요구되는 곳 외에, 리터럴, 주석, 그리고 JSDoc을 제외하고, 하나의 내부 ASCII 공백 또한 다음의 위치<strong>에만</strong> 나타납니다.</p>

<ol>
<li>줄에 뒤따르는 여는 괄호(<code>(</code>)와 임의의 (<code>if</code>, <code>for</code>, 혹은 <code>catch</code>와 같은)예약어를 구분.</li>
<li>줄에 앞서는 닫는 줄괄호(<code>}</code>)와 임의의 (<code>else</code> 혹은 <code>catch</code>와 같은)예약어를 구분. 여기에는 두 가지 예외가 있습니다:
<ol>
<li>함수의 첫 번째 인자 혹은 배열에서 첫 번째 원소인 객체 리터럴의 앞 (e.g. <code>foo({a: [{c: d}]})</code>).</li>
<li>템플릿 확장에서, 언어에 의해 금지된 경우
(e.g. <code>abc${1 + 2}def</code>).</li>
</ol></li>
<li>임의의 이항 혹은 삼항 연산자의 양쪽.</li>
<li>쉼표(<code>,</code>) 혹은 세미콜론(<code>;</code>) 뒤. 이러한 문자들 뒤에는 공백이 <em>절대</em> 허용되지 않는다는 것을 기억하십시오.</li>
<li>객체 리터럴에서 콜론(<code>:</code>) 뒤.</li>
<li>줄 끝의 주석이 시작되는 더블 슬래시(<code>//</code>)의 양쪽. 이곳에는 여러 개의 공백이 허용되지만, 반드시는 아닙니다.</li>
<li>JSDoc 주석의 여는 문자 뒤와 닫는 문자의 양쪽
(e.g. 타입 선언이나 형변환의 단형(short-form)에: <code>this.foo = /** @type
{number} */ (bar);</code> or <code>function(/** string */ foo) {</code>).</li>
</ol>

<h4 id="formatting-horizontal-alignment">4.6.3 수평 정렬: 권장하지 않음</h4>

<p><strong>용어 노트</strong>: <em>수평 정렬</em>이란 특정 토큰을 이전 라인의 다른 토큰 바로 아래에 위치하도록 코드에 가변적인 숫자의 공백을 추가하는 관례를
말합니다.</p>

<p>이 관례는 허용되지만, 구글 스타일에서는 <strong>일반적으로 권장되지 않습니다</strong>. 이미 수평 정렬이 사용된 곳에서 이를 <em>유지</em>할 필요도 없습니다.</p>

<p>정렬을 사용하지 않는 예시와 사용하는 예시가 있는데, 둘 다 허용되지만 후자는 권장되지 않습니다:</p>

<pre><code class="language-js prettyprint">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};
</code></pre>

<p>팁: 정렬은 가독성에 도움이 될 수 있지만, 이후의 유지보수에 문제를 만듭니다.
이후에 단 한줄만 건드렸을 때의 변화를 생각해보세요. 이 변화는 이전까지 맞춰져
있던 서식을 훼손할 수 있으며, 이는 허용됩니다.
이는 코드 작성자(아마도 여러분)에게 더 자주 근처 라인의 공백도 조정하도록 할
것이고, 서식을 다시 맞추는 작업을 연쇄적으로 발생시킬 수도 있습니다.
단 한줄의 변화가 이제는 <q>폭발 반경(blast radius)</q>을 갖게 되었습니다.
이는 최악의 경우 의미없이 바쁘기만 한 업무가 될 수 있습니다, 하지만 최선의
경우에도 버전 히스토리 정보를 손상시키고, 코드 리뷰어의 업무를
둔화(slows down)시키며 머지 충돌도 악화시킵니다.</p>

<h4 id="formatting-function-arguments">4.6.4 함수 인자</h4>

<p>모든 함수 인자를 함수 이름과 같은 줄에 넣으려고 하는 것이 좋습니다. 만약 80제한을 초과하려 한다면, 인자들은 읽기 좋은 형태로 줄 바꿈되어야 합니다. 공간을 절약하기 위해, 가능한 한 80자에 가깝게 포장하거나, 가독성을 향상시키기 위해 각 인자를 줄마다 넣을 수도 있습니다. 들여쓰기는 4 칸이어야 합니다. 괄호에 맞추는 것도 허용되지만 권장사항은 아닙니다. 아래는 인자 포장의 가장 흔한 패턴입니다:</p>

<pre><code class="language-js prettyprint">// Arguments start on a new line, indented four spaces. Preferred when the
// arguments don't fit on the same line with the function name (or the keyword
// "function") but fit entirely on the second line. Works with very long
// function names, survives renaming without reindenting, low on space.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // &#8230;
}

// If the argument list is longer, wrap at 80. Uses less vertical space,
// but violates the rectangle rule and is thus not recommended.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // &#8230;
}

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // &#8230;
}
</code></pre>

<h3 id="formatting-grouping-parentheses">4.7 그룹화 하는 괄호: 권장</h3>

<p>선택적으로 그룹화하는 괄호는 코드 작성자와 리뷰어가 괄호 없이도 코드가 잘못
해석될 여지가 없거나 읽기 더 쉽도록 한다는 데에 동의하는 경우에만 생략될 수
있습니다. 코드를 읽는 모든 이가 연산자 우선순위 표를 기억하고 있다고 가정하는
것은 합리적이지 <em>않</em>습니다.</p>

<p>다음과 같은 전체 표현식에 불필요한 괄호를 사용하지 마십시오:
<code>delete</code>, <code>typeof</code>, <code>void</code>, <code>return</code>, <code>throw</code>, <code>case</code>, <code>in</code>, <code>of</code>, 혹은 <code>yield</code>.</p>

<p>괄호는 형 변환에 필요합니다: <code>/** @type {!Foo} */ (foo)</code>.</p>

<h3 id="formatting-comments">4.8 주석</h3>

<p>이 섹션에서는 <em>구현 주석</em>을 다룹니다. JSDoc은 <a href="#jsdoc">??</a>에서 별도로 다뤄집니다..</p>

<h4 id="formatting-block-comment-style">4.8.1 블럭 주석 스타일</h4>

<p>블럭 주석은 둘러싼 코드와 같은 수준으로 들여쓰기됩니다.
<code>/* &#8230; */</code> 혹은 <code>//</code>-스타일이 될 수 있습니다.
다중 행<code>/* &#8230; */</code> 주석에서, 주석을 명확하게 하기 위해
그 다음 줄은 이전 줄의 <code>*</code>와 맞춰진 *로 시작해야 합니다.
&#8220;매개변수명&#8221; 형태의 주석은 값과 메서드명이 의미를 충분히 전달하지 못하는 경우 언제든 나타납니다.</p>

<pre><code class="language-js prettyprint">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code></pre>

<p>주석은 별표나 다른 문자로 그려진 상자로 둘러싸이지 않습니다.</p>

<p>JSDoc(<code>/** &#8230; */</code>)을 위와 같은 구현 주석에 사용하지 마십시오.</p>

<h2 id="language-features">5 언어의 특징</h2>

<p>Javascript는 많은 의심스러운(또한 위험하기도 한) 특징들을 포함합니다. 이
섹션은 사용되거나 사용되지 않을 수도 있는 특징들과 이들의 사용에 있어서
추가적인 제약 사항들을 기술합니다.</p>

<h3 id="features-local-variable-declarations">5.1 지역 변수 선언</h3>

<h4 id="features-use-const-and-let">5.1.1 <code>const</code>와 <code>let</code> 사용</h4>

<p>모든 지역 변수는 <code>const</code> 혹은 <code>let</code>과 함께 선언하십시오. 변수가 재할당 될 필요가 없는 한, 기본적으로 const를 사용하십시오. The <code class="badcode">var</code>
키워드는 사용되서는 안됩니다.</p>

<h4 id="features-one-variable-per-declaration">5.1.2 선언 당 하나의 변수</h4>

<p>모든 지역 변수 선언은 하나의 변수만을 선언합니다. <code class="badcode">let a = 1, b = 2;</code>와 같은 선언은 사용되지 않습니다.</p>

<h4 id="features-declared-when-needed">5.1.3 필요할때 선언, 가능한 빨리 초기화</h4>

<p>지역 변수는 습관적으로 이를 포함하는 블럭 혹은 유사 블럭 구조의 시작에서 선언되지 <strong>않</strong>습니다. 대신, 스코프를 최소화하기 위해 지역 변수는 이들이 처음으로 (필요에 맞게)사용되는 지점에서 가까운 곳에 선언됩니다.</p>

<h4 id="features-declare-types-as-needed">5.1.4 타입은 필요에 따라 선언</h4>

<p>JSDoc 타입 어노테이션은 선언의 윗줄 아니면 변수명 앞에 추가될 수 있씁니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];

/** @type {!Array&lt;number&gt;} */
const data = [];
</code></pre>

<p>팁: 컴파일러가 템플릿화된 타입은 추론할 수 있지만 매개변수는 그렇지 않은
경우가 많습니다. 이는 특히 리터럴 혹은 생성자 호출 초기화가 템플릿 매개변수의 타입(e.g. empty arrays, object, <code>Map</code>, 혹은 <code>Set</code>)에 대한 어떠한 값도 포함하지 않거나 변수가 클로저에서 수정된 경우에 그렇습니다. 그렇지 않으면 컴파일러는 템플릿 매개변수를 알 수 없는 것으로 추론하기 때문에 지역 변수 타입 어노테이션은 특히 이런 경우에 유용합니다.</p>

<h3 id="features-array-literals">5.2 배열 리터럴</h3>

<h4 id="features-arrays-trailing-comma">5.2.1 뒤따르는 쉼표를 사용할 것</h4>



<p>마지막 원소와 닫는 대괄호 사이에 개행이 있더라도 뒤따르는 쉼표를 포함하십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">const values = [
  'first value',
  'second value',
];
</code></pre>

<h4 id="features-arrays-ctor">5.2.2 가변 <code>Array</code> 생성자를 사용하지 말 것</h4>

<p>이 생성자는 인자가 추가되거나 제거되면 오류가 발생하기 쉽습니다. 대신 리터럴을 사용하십시오.</p>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code></pre>

<p>세 번째 경우를 제외하고는 예상대로 동작합니다: 만약 <code>x1</code>이 정수이면 <code>a3</code>는 <code>x1</code>의 사이즈이면서 모든 원소가 <code>undefined</code>인 배열이 됩니다. 만약 <code>x1</code>이 다른 숫자이면 예외가 던져질 것이고, 임의의 다른 타입이면 단일 원소 배열이 될 것입니다.</p>

<p>대신, 다음과 같이 씁니다</p>

<pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code></pre>

<p><code> new Array(length)</code>를 사용하여 명시적으로 주어진 길이의 배열을 할당하는 것은 적절한 경우에만 허용됩니다.</p>

<h4 id="features-arrays-non-numeric-properties">5.2.3 숫자가 아닌 프로퍼티</h4>

<p>배열에 (<code>length</code> 이외에)숫자가 아닌 프로퍼티를 정의하거나 사용하지 마십시오. 대신 <code>Map</code> (혹은 <code>Object</code>)를 사용하십시오.</p>

<h4 id="features-arrays-destructuring">5.2.4 비구조화(Destructuring)</h4>

<p>배열 리터럴은 (단일 배열이나 순회 가능한 객체로부터 여러 개의 값을 가져오는것과 같은)비구조화 할당의 왼쪽에서 사용될 수 있습니다. 마지막 <q>나머지</q> 원소가 (<code>...</code>와 변수명 사이에 공백 없이)포함될 수 있습니다. 원소가 사용되지 않는 경우에는 생략되어야 합니다.</p>

<pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code></pre>

<p>비구조화는 함수 매개변수에서도 사용될 수 있습니다 (매개변수 이름은 필요하지만 무시된다는 점을 기억하십시오). 비구조화된 배열 매개변수가 선택 사항이라면, 항상 <code>[]</code>를 기본값으로 명시하고, 왼쪽에 기본값을 제공하십시오:</p>

<pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };
</code></pre>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };
</code></pre>

<p>팁: 여러 값을 함수의 매개변수 혹은 반환값으로 전달할 때는, 개개의 원소에 명명이 가능하고 각각 다른 타입을 명시할 수 있기 때문에 가능하면 배열 비구조화보다 객체 비구조화를 선호하십시오.</p>

<h4 id="features-arrays-spread-operator">5.2.5 전개 연산자</h4>

<p>배열 리터럴은 하나 이상의 다른 순회 가능한(iterable) 객체에서 원소들을 평평하게(faltten) 하기 위해 전개 연산자(<code>...</code>)를 포함할 수도 있습니다. 전개 연산자는 <code>Array.prototype</code>을 사용하는 더 어색한 구문 대신에 사용되어야 합니다. <code>...</code> 뒤에는 공백이 없습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">[...foo]   // preferred over Array.prototype.slice.call(foo)
[...foo, ...bar]   // preferred over foo.concat(bar)
</code></pre>

<h3 id="features-object-literals">5.3 객체 리터럴</h3>

<h4 id="features-objects-use-trailing-comma">5.3.1 뒤따르는 쉼표를 사용할 것</h4>

<p>마지막 프로퍼티와 닫는 중괄호 사이에 개행이 있을 때마다 쉼표를 포함합니다.</p>

<h4 id="features-objects-ctor">5.3.2 <code>Object</code> 생성자 사용하지 말 것</h4>

<p><code>Object</code>가 <code>Array</code>와 동일한 문제를 갖고 있진 않더라도, 일관성을 위해 허용되지 않습니다. 대신 객체 리터럴(<code>{}</code> 혹은 <code>{a: 0, b: 1, c: 2}</code>)을 사용하십시오.</p>

<h4 id="features-objects-mixing-keys">5.3.3 따옴표로 감싼 키와 감싸지 않은 키를 혼용하지 말 것</h4>

<p>객체 리터럴은 (따옴표로 감싸지 않은 키 및 또는 기호로)<em>구조</em> 혹은
(따옴표로 감싸고 혹은 계산된 키값으로)<em>사전(dicts)</em>을 나타낼 수 있습니다. 하나의 객체 리터럴에 이러한 키 유형을 혼용하지 마십시오.</p>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">{
  a: 42, // struct-style unquoted key
  'b': 43, // dict-style quoted key
}
</code></pre>

<h4 id="features-objects-computed-property-names">5.3.4 계산된 프로퍼티 이름</h4>

<p>계산된 프로퍼티 이름(e.g., <code>{['key' + foo()]: 42}</code>)는 허용되며,
계산된 프로퍼티가 기호(e.g., <code>[Symbol.iterator]</code>)가 아닌 한,
사전 스타일 (따옴표를 사용하는) 키로 간주됩니다(즉, 따옴표를 사용하지 않는 키와
혼용돼서는 안됩니다).
열거 값 또한 계산된 키에 사용될 수 있습니다, 하지만 같은 리터럴에서 비-열거형 키와 혼용되서는 안됩니다.</p>

<h4 id="features-objects-method-shorthand">5.3.5 메서드 축약</h4>

<p>메서드는 객체 리터럴에서 바로 뒤에 <code>function</code>이나 arrow function 리터럴이 있는 대신 메서드 축약을 사용하여 정의될 수 있습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
</code></pre>

<p>arrow function에서 <code>this</code>가 객체 리터럴 외부의 스코프를 참조하는
것과 달리, 메서드 축약이나 <code>function</code>에서 <code>this</code>는
객체 리터럴 자체를 참조한다는 점을 알아두십시오.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () =&gt; this.stuff,  // Returns 'fruit'
    };
  }
}
</code></pre>

<h4 id="features-objects-shorthand-properties">5.3.6 프로퍼티 축약</h4>

<p>프로퍼티 축약은 객체 리터럴에서 허용됩니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code></pre>

<h4 id="features-objects-destructuring">5.3.7 비구조화</h4>

<p>객체 비구조화 패턴은 하나의 객체로부터 여러 값을 비구조화하여 풀어내기 위해 할당의 왼쪽에서 사용될 수 있습니다.</p>

<p>비구조화된 객체는 또한 함수 매개변수로도 사용될 수 있지만, 단일 수준의
따옴표를 사용하지 않은 축약형 프로퍼티로 가능한 한 단순하게 유지되어야 합니다.
더 깊은 수준의 중첩과 계산된 프로퍼티는 매개변수 비구조화에서 사용되지 않을 수
있습니다. 비구조화된 매개변수(<code class="badcode">{str} = {str: 'some default'}</code> 보다는 <code>{str = 'some default'} = {}</code>와 같이)의 왼쪽에 임의의 기본값을 명시하고, 만약 비구조화된 객체 자체가 선택적이라면 기본값은 <code>{}</code>여야 합니다. 비구조화된 파라미터에 대한 JSDoc은 어떤 이름(이름은 사용되지 않지만 컴파일러에 의해 필요합니다)이라도 될 수 있습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {})
</code></pre>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code></pre>

<p>비구조화는 <code>goog.require</code>에서도 쓰일 수 있으며, 이 경우 포장되서는 안되며 전체 구문은 길이에 관계 없이 한 줄을 차지해야 합니다(<a href="#file-goog-require">??</a>을 참고하십시오). </p>

<h4 id="features-objects-enums">5.3.8 열거형</h4>

<p>열거형은 객체 리터럴에 <code>@enum</code> 애노테이션을 추가함으로써 정의됩니다.
정의된 이후에는 추가적인 프로퍼티가 추가되지 않을 수 있습니다. 열거형은 상수여야 하며, 모든 열거 값은 깊은 불변(deeply immutable) 객체여야 합니다.</p>

<pre><code class="language-js prettyprint">/**
 * Supported temperature scales.
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * An enum with two options.
 * @enum {number}
 */
const Option = {
  /** The option used shall have been the first. */
  FIRST_OPTION: 1,
  /** The second among two options. */
  SECOND_OPTION: 2,
};
</code></pre>

<h3 id="features-classes">5.4 클래스</h3>

<h4 id="features-classes-constructors">5.4.1 생성자</h4>

<p>구체 클래스(concrete class)에 대한 생성자는 선택사항입니다. 서브클래스 생성자는 <code>this</code> 접근으로 필드 등을 설정하기 전에 <code>super()</code>를 호출해야 합니다. 인터페이스는 생성자를 정의해선 안됩니다.</p>

<h4 id="features-classes-fields">5.4.2 필드</h4>

<p>모든 구체 클래스의 필드(i.e. 메서드 외의 모든 프로퍼티)를 생성자에서
설정하십시오. 다시 재할당 되지 않는 필드는 <code>@const</code>로 표기하십시오
(깊은 불변일 필요는 없습니다). Private 필드는 <code>@private</code>으로
표기되어야 하며 이들의 이름은 언더스코어로 끝나야 합니다. 필드는 절대 구체 클래스의 <code>prototype</code>에 설정하지 않습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();
  }
}
</code></pre>

<p>팁: VM의 최적화 능력을 상당히 저해하기 때문에 생성자가 종료된 후에
프로퍼티는 절대로 인스턴스에 추가되거나 제거되어서는 안됩니다. 만약 필요한 경우,
나중에 초기화될 필드는 이후의 형태 변화를 방지하기 위해 생성자에서 명시적으로
<code>undefined</code>로 설정되어야 합니다. 객체에 <code>@struct</code>를
추가하면 선언되지 않은 프로퍼티가 추가/접근되는지 검사합니다. 클래스는
기본적으로 추가됩니다.</p>

<h4 id="features-classes-computed-properties">5.4.3 계산된 프로퍼티</h4>



<p>계산된 프로퍼티는 클래스에서 프로퍼티가 기호인 경우에만 사용될 수 있습니다. 
사전 스타일 프로퍼티(<a href="#features-objects-mixing-keys">??</a>에 정의된 
대로, 이는 따옴표로 감싸거나 계산된 비 기호 키를 말합니다)는 허용되지 않습니다.
<code>[Symbol.iterator]</code> 메서드는 논리적으로 순회 가능한 임의의 
클래스에서 정의되어야 합니다. 이외에 <code>Symbol</code>은 적게 사용해야 
합니다.</p>

<p>팁: 임의의 다른 내장 기호(e.g. <code>Symbol.isConcatSpreadable</code>) 사용에 주의하십시오. 이들은 컴파일러에서 폴리필되지 않으므로 구형 브라우저에서는 동작하지 않을 것입니다.</p>

<h4 id="features-classes-static-methods">5.4.4 정적 메서드 </h4>



<p>가독성에 간섭하지 않는 곳에서는 private static 메서드보다는 모듈-지역 함수를 사용하십시오.</p>

<p>정적 메서드는 기반클래스 자체에서만 호출되어야 합니다. 정적 메서드는 
생성자이거나 서브클래스의 생성자일 수도 있는 동적인 인스턴스를 포함하는 
변수에서 호출되어서는 안됩니다(그리고 이를 만족하는 경우 
<code>@nocollapse</code>로 정의되어야 합니다), 그리고 메서드 자체를 정의하지 
않는 서브클래스에서 직접 호출되어서도 안됩니다.</p>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // discouraged: don&apos;t call static methods dynamically
Sub.foo();  // illegal: don&apos;t call static methods on subclasses that don&apos;t define it themselves
</code></pre>

<h4 id="features-classes-old-style">5.4.5 구형 방식의 클래스 선언</h4>

<p>ES6가 선호되는 와중에도, ES6 클래스를 사용할 수 없는 경우가 있을 수 있습니다. 예를 들어:</p>

<ol>
<li><p>서브클래스를 생성하는 프레임워크를 포함하여 서브클래스가 존재하거나
존재할 예정이면, 즉시 ES6 구문을 사용하도록 변경할 수 없습니다. 해당 클래스가
ES6 구문을 사용하고자 하는 경우, ES6 클래스 구문을 사용하지 않는 모든 하위
서브클래가 변경되어야 합니다.</p></li>
<li><p>ES6 수퍼클래스의 생성자는 <code>super</code> 호출이 반환하기 전까지
인스턴스의 <code>this</code> 값에 접근할 수 없기 때문에, 수퍼클래스 생성자를
호출하기 전에 알려진 <code>this</code> 값이 필요한 프레임워크.</p></li>
</ol>

<p>다른 모든 면에서 스타일 가이드는 여전히 이 코드에 
적용합니다:<code>let</code>, <code>const</code>,
기본 매개변수, rest, 그리고 arrow function는 모두 적절하게 사용되어야 합니다.</p>

<p><code>goog.defineClass</code>는 ES6 클래스 구문과 닮은 유사 클래스 정의를 허용합니다:</p>

<pre><code class="language-javascript">let C = goog.defineClass(S, {
  /**
   * @param {string} value
   */
  constructor(value) {
    S.call(this, 2);
    /** @const */
    this.prop = value;
  },

  /**
   * @param {string} param
   * @return {number}
   */
  method(param) {
    return 0;
  },
});
</code></pre>

<p>대신, 모든 새로운 코드에는 <code>goog.defineClass</code>가 선호되어야 합니다, 더 전통적인 구문들도 허용됩니다..</p>

<pre><code class="language-javascript">/**
  * @constructor @extends {S}
  * @param {string} value
  */
function C(value) {
  S.call(this, 2);
  /** @const */
  this.prop = value;
}
goog.inherits(C, S);

/**
 * @param {string} param
 * @return {number}
 */
C.prototype.method = function(param) {
  return 0;
};
</code></pre>

<p>수퍼 클래스가 있는 경우, 인스턴스 당 프로퍼티는 생성자에서 수퍼클래스 생성자 
호출 뒤에 정의되어야 합니다. 메서드는 생성자의 프로토타입에 정의되어야 합니다. </p>

<p>생성자의 프로토타입 계층을 올바르게 정의하는 것은 처음에 보이는 것 보다 더 어렵습니다! 그러한 이유에서,
<a href="http://code.google.com/closure/library/">the Closure Library </a>으로부터 <code>goog.inherits</code>를 사용하는 것이 최선입니다.</p>

<h4 id="features-classes-prototypes">5.4.6 <code>prototype</code>을 직접 조작하지 말 것</h4>

<p><code>class</code>키워드는 <code>prototype</code> 프로퍼티를 정의하는 것
보다 클래스 정의를 간결하고 더 읽기 좋게 합니다. 평범한 구현 코드는 이 객체를
조작할 일이 없습니다, 그래도 여전히 이 객체는 <a href="#features-classes-old-style">??</a>에 정의된대로 <code>@record</code>
인터페이스와 클래스를 정의하기에 유용합니다. 믹스인과 내장 객체의 프로토타입을 변경하는 것은 명시적으로 금지됩니다.</p>

<p><strong>예외</strong>: (Polymer 혹은 Angular와 같은) 프레임워크 코드는 <code>prototype</code>이 필요할 수 있습니다, 이를 피하기 위해 더 나쁜 해결책에 의존해서는 안됩니다.</p>

<p><strong>예외</strong>: 인터페이스에 필드를 정의하는 것 (<a href="#features-classes-interfaces">??</a> 참고).</p>

<h4 id="features-classes-getters-and-setters">5.4.7 Getters와 Setters</h4>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">JavaScript getter and setter properties</a>를 사용하지 마십시오. 이들은 잠재적으로 놀랍고 추론하기도 어려우며, 컴파일러에서의 지원도 제한되어 있습니다. 대신 일반적인 메서드를 제공하십시오.</p>

<p><strong>예외</strong>: (Angular나 Polymer와 같은)데이터 바인딩 프레임워크로 작업할 때에는 getter와 setter가 드물게 사용될 수 있습니다. 하지만, 컴파일러 지원이 제한된다는 점을 기억하십시오. 이들이 사용되면 클래스 혹은 객체 리터럴에서, 혹은 불가능하다면 <code>Object.defineProperties</code>로 <code>get foo()</code>와 <code>set foo(value)</code> 둘 중 하나는 정의되어야 합니다. 프로퍼티 이름 변경에 간섭하는 <code>Object.defineProperty</code>는 사용하지 마십시오. Getter는 관측 가능한 상태가 바뀌어서는 <strong>안됩니다</strong>.</p>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">class Foo {
  get next() { return this.nextId++; }
}
</code></pre>

<h4 id="features-classes-overriding-tostring">5.4.8 toString 오버라이딩</h4>

<p>The <code>toString</code> 메서드는 오버라이드 될 수 있습니다, 하지만 반드시 성공해야 하며 부수 효과(side effect)가 없어야 합니다.</p>

<p>팁: 예외적인 조건이 무한 루프를 만들 수도 있으므로 toString에서 다른 메서드를 호출할 때는 특히 주의하십시오.</p>

<h4 id="features-classes-interfaces">5.4.9 인터페이스</h4>

<p>인터페이스는 <code>@interface</code> 혹은 <code>@record</code>와 함께 선언될
것입니다. <code>@record</code>와 함께 선언된 인터페이스는 클래스 혹은 객체
리터럴에 의해 (<code>@implements</code>를 통해)명시적으로 혹은 암시적으로
구현될 수 있습니다.</p>

<p>인터페이스의 모든 비 정적 메서드 본문은 빈 블럭이어야 합니다. 필드는 인터페이스 본문 뒤에 <code>prototype</code>에 스텁으로 정의되어야 합니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

/** @type {number} The number of attempts before giving up. */
Frobnicator.prototype.attempts;
</code></pre>

<h3 id="features-functions">5.5 함수</h3>

<h4 id="features-functions-top-level-functions">5.5.1 상위 수준 함수</h4>

<p>export되는 함수는 <code>exports</code>객체에 직접 정의되거나, 혹은 로컬에서 선언되고 별도로 export될 수도 있습니다. export되지 않는 함수는 권장되며 <code>@private</code>로 선언되서는 안됩니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">/** @return {number} */
function helperFunction() {
  return 42;
}
/** @return {number} */
function exportedFunction() {
  return helperFunction() * 2;
}
/**
 * @param {string} arg
 * @return {number}
 */
function anotherExportedFunction(arg) {
  return helperFunction() / arg.length;
}
/** @const */
exports = {exportedFunction, anotherExportedFunction};
</code></pre>

<pre><code class="language-js prettyprint">/** @param {string} arg */
exports.foo = (arg) =&gt; {
  // do some stuff ...
};
</code></pre>

<h4 id="features-functions-nested-functions">5.5.2 중첩 함수와 클로저</h4>

<p>함수는 중첩된 함수 정의를 포함할 수 있습니다. 함수에 이름을 주는 것이 유용한 경우, 지역 <code>const</code>에 할당되어야 합니다.</p>

<h4 id="features-functions-arrow-functions">5.5.3 arrow function</h4>

<p>arrow function는 간결한 구문과 <code>this</code>로 인한 많은 어려움을
해결합니다. 특히 중첩되는 함수에 대해 <code>function</code> 키워드보다 화살표
함수를 선호하도록 하십시오(<a href="#features-objects-method-shorthand">??</a>
참고).</p>

<p><code>f.bind(this)</code>보다, 특히 <code>goog.bind(f, this)</code>보다
arrow function를 선호하십시오. <code>const self = this</code> 작성을 피하십시오.
arrow function는 특히 때때로 예기치않은 추가적인 인자를 넘기는 콜백에
유용합니다.</p>

<p>화살표의 오른쪽은 하나의 표현식이나 블럭이 될 수 있습니다. 인자가 하나이고
비구조화되지 않은(non-destructured) 경우 인자들을 감싸는 괄호는 선택사항입니다.
</p>

<p>팁: 인자가 추가된 경우에 괄호가 없어도 코드는 여전히 타당하게(하지만
올바르지 않게) 파싱되므로, 단일 인자 화살표에도 괄호를 사용하는 습관은 좋습니다.
</p>

<h4 id="features-functions-generators">5.5.4 Generators</h4>

<p>Generators는 여러 유용한 추상화를 가능케 하고 필요에 따라서 사용될 수 있습니다.</p>

<p>generator 함수를 정의할 때는 <code>*</code>을 <code>function</code> 키워드에
붙이며, 공백으로 함수 이름과 구분합니다. delegating yeilds를 사용할 때는
<code>*</code>을 <code>yeild</code> 키워드에 붙입니다. </p>

<p>예시:</p>

<pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
</code></pre>

<h4 id="features-functions-parameters">5.5.5 파라미터</h4>

<p>모든 타입이 생략되는 동일 시그니처 <code>@override</code>를 제외하고, 함수 파라미터는 함수의 정의 앞에 JSDoc 어노테이션으로 타입이 명시되어야 합니다.</p>

<p>파라미터 타입은 파라미터 이름의 바로 앞에 (<code>(/** number */ foo, /** string */ bar) =&gt; foo + bar</code>처럼) 인라인으로 명시될 <em>수</em> 있습니다. 인라인과 <code>@param</code> 타입 어노테이션은 같은 함수 정의에서 혼용돼서는 <em>안됩니다</em>.</p>

<h5 id="features-functions-default-parameters">5.5.5.1 기본 파라미터</h5>

<p>파라미터 목록에는 동등 연산자를 사용하는 선택적 파라미터가 허용됩니다. 선택적 파라미터는 동등 연산자의 양쪽에 공백을 포함해야 하고, 필수 파라미터 처럼 명명되어야 하며
(i.e., <code>opt_</code>가 앞에 붙지 않는), JSDoc 타입에서 <code>=</code> 접미사를 사용하고, 필수 파라미터 이후에 위치하며,
관측 가 능한 부수 효과(side effect)를 만들어내는 초기자를 사용하지 않습니다.
모든 선택적 파라미터는 함수 선언에서 그 값이 <code>undefinedl</code>라 하더라도 기본값을 가져야 합니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} required This parameter is always needed.
 * @param {string=} optional This parameter can be omitted.
 * @param {!Node=} node Another optional parameter.
 */
function maybeDoSomething(required, optional = '', node = undefined) {}
</code></pre>

<p>기본 파라미터를 아껴 사용하십시오.
자연적인 순서가 없는 소수의 선택적 파라미터가 있는 경우에는 읽기 좋은 API를 만들기 위해 l (<a href="#features-objects-destructuring">??</a>에서와 같은) 분해를 사용하십시오.</p>

<p>Note: Python의 기본 파라미터와는 달리, 초기자는 매번 기본값이 사용될 때 평가되기 때문에 단일 객체가 함수 호출 간에 공유되지 않으므로 (<code>{}</code> or <code>[]</code>와 같은)새로운 가변(mutable) 객체를 반환하는 초기자를 사용해도 괜찮습니다.</p>

<p>Tip: 함수 호출을 포함한 임의의 표현식이 초기자로 사용될 수는 있지만, 이는 가능한 한 단순하게 유지되어야 합니다.
함수 호출 사이에 의도치 않은 결합(coupling)을 낳을 수 있으므로, 공유된 가변 상태를 노출하는 초기자를 피하십시오.</p>

<h5 id="features-functions-rest-parameters">5.5.5.2 Rest 파라미터</h5>

<p><code>arguments</code>에 접근하는 대신 <em>Rest</em> 파라미터를 사용하십시오. Rest 파라미터는 JSDoc에서 <code>...</code> 접미사로 타입을 명시합니다. Rest파라미터는 목록에서 마지막 파라미터여야 합니다. <code>...</code>와 파라미터 이름 사이에는 공백이 없습니다. Rest 파라미터를 <code>var_args</code>로 명명하지 마십시오. 내장된 이름과 혼동될 수 있으므로 절대로 지역변수나 파라미터를 <code>arguments</code>로 명명하지 마십시오.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @param {!Array&lt;string&gt;} array This is an ordinary parameter.
 * @param {...number} numbers The remainder of arguments are all numbers.
 */
function variadic(array, ...numbers) {}
</code></pre>

<h4 id="features-functions-returns">5.5.6 반환값</h4>

<p>모든 타입이 생략되는 동일한 시그니처 <code>@override</code>를 제외하고, 함수의 반환 타입은 함수 정의 바로 위의 JSDoc에 명시되어야 합니다.</p>

<h4 id="features-functions-generics">5.5.7 제네릭</h4>

<p>필요한 경우 클래스 위의 JSDoc에 <code>@template TYPE</code>을 사용하여 제네릭 함수와 메서드를 선언하십시오.</p>

<h4 id="features-functions-spread-operator">5.5.8 전개 연산자</h4>

<p>함수 호출은 전개 연산자(<code>...</code>)를 사용할 수 있습니다. 배열이나 iterable한 객체를 가변 인자 함수의 여러 파라미터로 풀 때 <code>Function.prototype.apply</code>에 전개 연산자를 사용하는 것을 선호하십시오. <code>...</code> 뒤에는 공백이 없습니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code></pre>

<h3 id="features-string-literals">5.6 문자열 리터럴</h3>

<h4 id="features-strings-use-single-quotes">5.6.1 작은 따옴표 사용</h4>

<p>일반적인 문자열 리터럴은 큰 따옴표(<code>&ldquo;</code>) 보다는 작은 따옴표(<code>&lsquo;</code>)로 구분됩니다.</p>

<p>Tip: 문자열이 작은 따옴표 문자를 포함하면, 따옴표를 이스케이프 하는 일을 피하기 위해 템플릿 문자열 사용을 고려하십시오. </p>

<p>일반적인 문자열 리터럴은 여러 줄을 차지하지 않을 수도 있습니다.</p>

<h4 id="features-strings-template-strings">5.6.2 템플릿 문자열</h4>

<p>특히 여러 문자열이 관련되는 경우, 지나치게 복잡한 문자열 이어붙이에는 (<code>`</code>로 구분되는) 템플릿 문자열을 사용하십시오. 템플릿 문자열은 여러 줄을 차지할 수도 있습니다.</p>

<p>만약 템플릿 문자열이 여러 줄을 차지하면, 추가되는 공백이 문제 없더라도 인근 블럭의 들여쓰기를 따를 필요는 없습니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code></pre>

<h4 id="features-strings-no-line-continuations">5.6.3 line continuation 금지</h4>

<p>일반적인 문자열과 템플릿 문자열 모두에 <em>line continuations</em> (문자열 리터럴 내에서 백슬래시로 줄을 끝내는 것)을 사용하지 마십시오. ES5가 허용하더라도, 슬래시 뒤에 따라오는 공백이 있는 경우 이는 까다로운 에러가 될 수 있으며, 독자들에게도 덜 명확합니다.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';
</code></pre>

<p>대신, 다음과 같이 작성하십시오</p>

<pre><code class="language-js prettyprint">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
</code></pre>

<h3 id="features-number-literals">5.7 숫자 리터럴</h3>

<p>16진수, 8진수, 그리고 2진수 숫자는 소문자와 함께 각각 <code>0x</code>, 
<code>0o</code>, 그리고 <code>0b</code> 접두사를 사용하여 10진수, 16진수, 8진수,
혹은 2진수로 표기될 수 있습니다. 바로 뒤에 <code>x</code>, <code>o</code>, or <code>b</code>가 따라오지 않는 한, 절대 앞에 0을 포함하지 마십시오.</p>

<h3 id="features-control-structures">5.8 제어 구조</h3>

<h4 id="features-for-loops">5.8.1 For 루프</h4>

<p>ES6에서, 언어는 서로 다른 세 종류의 <code>for</code> 루프를 갖고
있습니다. 모두 사용되지만, 가능한 경우에는 <code>for</code>-<code>of</code> 루프가 선호되는 것이 좋습니다.</p>

<p><code>for</code>-<code>in</code> 루프는 사전 스타일 객체에서만 사용될 수
있습니다(<a href="#features-objects-mixing-keys">??</a>을 보세요). 그리고 배열을 순회하는 데에는 사용되지 않는 것이 좋습니다.
<code>forl</code>-<cod>inl</cod> 루프에서는 원치않는 프로토타입 속성을 제외하기 위해 <code>Object.prototype.hasOwnProperty</code>가 사용되는 것이 좋습니다. 
가능하면 <code>for</code>-<code>inll</code>보다 <code>for</code>-<cod>of</cod>와 <code>Object.keys</code>를 선호하십시오.</p>

<h4 id="features-exceptions">5.8.2 예외</h4>

<p>예외는 언어의 중요한 부분이며 예외 상황이 발생했을 때 사용돼야 합니다. 항상 <code>Error</code> 혹은 <code>Error</code>의 서브클래스를 던져야 합니다: 절대 문자열 리터럴이나 다른 객체를 던지지 마십시오. <code>Error</code>를 생성할 때는 언제나 <code>new</code>를 사용하십시오.</p>

<p>커스텀 예외는 함수로부터 추가적인 오류 정보를 전달하는 훌륭한 방법입니다. 이들은 네이티브 <code>Error</code> 타입이 충분하지 않은 곳에서 사용돼야 합니다.</p>

<p>(오류 컨테이너 참조 타입이나, 오류 속성과 함께 객체를 반환하는)임기응변식 오류 처리보다는 예외를 던지는 것을 선호하십시오.</p>

<h5 id="features-empty-catch-blocks">5.8.2.1 빈 catch 블럭</h5>

<p>캐치(catch)된 예외에 아무것도 하지 않는 것은 아주 드문 경우에만 옳습니다. 어떡해도 아무 행동도 하지 않는 것이 적절한 때에는, 그에 대한 정당한 이유가 주석에 설명되어야 합니다.</p>

<pre><code class="language-js prettyprint">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code></pre>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">   try {
    shouldFail();
    fail('expected an error');
  }
  catch (expected) {}
</code></pre>

<p>Tip: 일부 다른 언어와는 달리, 위와 같은 패턴은 <code>fail</code>에서 던져진 오류를 잡기 때문에 제대로 동작하지 않습니다. 대신 <code>assertThrows()</code>를 사용하십시오.</p>

<h4 id="features-switch-statements">5.8.3 Switch문</h4>

<p>switch 블럭의 괄호{} 내부는 하나 이상의 구문 그룹입니다. 각 구문 그룹은 하나 이상의 구문들이 따르는 하나 이상의 switch 라벨(<code>case FOO</code> 혹은 <code>default:</code>)로 이루어집니다</p>

<h5 id="features-switch-fall-through">5.8.3.1 Fall-through: 주석</h5>

<p>switch 블럭에서, 각 구문 그룹은 (<code>break</code>, <code>return</code> 혹은 예외를 <code>throw</code>해서)갑자기(abruptly) 끝나거나, 다음 구문 그룹으로 실행이 계속될 수 있거나 계속됨을 나타내기 위해 주석으로 표시됩니다. fall-trhough임을 전달할 수 있는 어떤 주석도 좋습니다(주로 <code>// fall trhough</code>). 이 특별한 주석은 switch 블럭의 마지막 구문 그룹에서는 필요치 않습니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code></pre>

<h5 id="features-switch-default-case">5.8.3.2 <code>default</code> 케이스가 있어야 함</h5>

<p>각 switch <code>default</code> 구문 그룹을 비어 있더라도 포함합니다.</p>

<h3 id="features-this">5.9 this</h3>

<p><code>this</code>는 오직 클래스 생성자와 메서드 혹은 그 안의 arrow function 에서만 사용하십시오. 이외의 <code>this</code> 사용은 바로 인접한 함수의 JSDoc에서 명시적인 <code>@this</code> 선언이 있어야 합니다.</p>

<p>절대로 <code>this</code>를 전역 객체, <code>eval</code>의 컨텍스트, 이벤트의 target, 혹은 불필요하게 <code>call()</code>되거나 <code>apply()</code>된 함수를 참조하는 데에 사용하지 마십시오.b</p>

<h3 id="disallowed-features">5.10 허용되지 않는 기능</h3>

<h4 id="disallowed-features-with">5.10.1 with</h4>

<p><code>with</code> 키워드를 사용하지 마십시오. 코드를 이해하기 어렵게 만들며 ES5의 strict mode에서는 금지됐습니다.</p>

<h4 id="disallowed-features-dynamic-code-evaluation">5.10.2 동적 코드 평가 (evaluation)</h4>

<p>(코드 로더의 경우를 제외하고) <code>eval</code> 혹은 <code>Function(...string)</code> 생성자를 사용하지 마십시오. 이러한 기능들은 잠재적으로 위험하여 CSP 환경에서는 제대로 동작하지 않습니다.</p>

<h4 id="disallowed-features-automatic-semicolon-insertion">5.10.3 자동 세미콜론 삽입</h4>

<p>(위에 적힌 것 처럼 함수와 클래스 선언을 제외하고)항상 구문을 세미콜론으로 끝내십시오.</p>

<h4 id="disallowed-features-non-standard-features">5.10.4 비표준 기능</h4>

<p>비표준 기능을 사용하지 마십시오. 제거된 오래된 기능들(e.g., <code>WeakMap.clear</code>), 아직 표준화되지 않은 기능들(e.g., 현재 작업중인 TC39 초안, 어떤 단계에 있는 제안 사항, 제안되었지만 아직 완성되지 않은 웹표준),  혹은 일부 브라우저에만 구현된 기능들이 포함됩니다. 현재 ECMA-262 혹은 WHATWG 표준에 정의된 기능만 사용하십시오. (Chrome 확장 혹은 Node.js와 같이 구체적인 API에 대해 작성한 프로젝트는 당연히 그러한 API를 사용할 수 있습니다). (특정한 외부 트랜스파일러와 같은)비표준 언어 "확장"은 금지됩니다.</p>

<h4 id="disallowed-features-wrapper-objects">5.10.5 기본(primitive) 타입에 대한 래퍼(wrapper) 객체</h4>

<p>절대 기본 객체 래퍼(<code>Boolean</code>, <code>Number</code>, <code>String</code>, <code>Symbol</code>)에 <code>new</code>를 사용해서는 안되며, 타입 애노테이션에 포함해서도 안됩니다.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
</code></pre>

<p>래퍼는 (<code>+</code>를 사용하거나 빈 문자열을 이어붙이는 것 보다 선호되는)coercing이나 기호를 생성하는 함수로서 호출될 수도 있습니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected
</code></pre>

<h4 id="disallowed-features-modifying-builtin-objects">5.10.6 내장 객체 변형</h4>

<p>절대 내장 타입의 생성자나 프로토타입에 메서드를 추가하여 변형해서는 안됩니다. 이런 동작을 하는 라이브러리 사용을 피하십시오. 가능한 곳에는 JSCompiler의 런타임 라이브러리가 표준을 준수하는 폴리필(polyfills)을 제공할 것입니다. 이외에는 내장 객체를 수정할 수 없습니다.</p>

<p>반드시 필요한 게(e.g. 서드 파티 API에서 필요한 경우) 아니라면 전역 객체에 기호를 추가하지 마십시오.</p>

<h2 id="naming">6 네이밍</h2>

<h3 id="naming-rules-common-to-all-identifiers">6.1 모든 식별자에 공통적인 규칙</h3>

<p>식별자는 오직 ASCII 글자와 숫자, 그리고 아래에 나열된 소수의 사례들, 언더스코와 (Angular와 같은 프레임워크에서 필요할 때)아주 드물게 달러 표시($)만이 사용됩니다.</p>

<p>가능하면 이치에 맞는 설명적인 이름을 사용하십시오. 새로운 독자가 코드를 바로 이해할 수 있게 하는 것이 훨씬 더 중요하므로, 수평 공간 절약할 걱정을 하지는 마십시오. 프로젝트 바깥의 독자에게 모호하거나 친숙하지 않은 축약을 사용하지 마십시오. 또한 단어에서 글자를 지워서 축약하지도 마십시오.</p>

<pre><code class="language-js prettyprint">priceCountReader      // No abbreviation.
numErrors             // "num" is a widespread convention.
numDnsConnections     // Most people know what "DNS" stands for.
</code></pre>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">n                     // Meaningless.
nErr                  // Ambiguous abbreviation.
nCompConns            // Ambiguous abbreviation.
wgcConnections        // Only your group knows what this stands for.
pcReader              // Lots of things can be abbreviated "pc".
cstmrId               // Deletes internal letters.
kSecondsPerDay        // Do not use Hungarian notation.
</code></pre>

<h3 id="naming-rules-by-identifier-type">6.2 식별자 유형별 규칙</h3>

<h4 id="naming-package-names">6.2.1 패키지 이름</h4>

<p>패키지 이름은 모두 <code>lowerCamelCase</code>입니다. 예를 들어, <code class="badcode">my.examplcode.deepspace</code>나 <code class="badcode">my.example_code.deep_space</code>가 아니라 <code>my.exampleCode.deepSpace</code>입니다.</p>

<h4 id="naming-class-names">6.2.2 클래스 이름</h4>

<p>클래스, 인터페이스, 레코드와 typedef 이름은 <code>UpperCamelCase</code>로 작성됩니다. 익스포트되지 않는 클래스는 지역적입니다: 이들은 <code>@private</code>으로 표시되지 않으므로 끝에 언더스코어를 붙여 명명하지 않습니다.</p>

<p>타입 이름은 주로 명사나 명사구입니다. 예를 들어, <code>Request</code>, <code>ImmutableList</code>, 또는 <code>VisibilityMode</code>가 있습니다. 추가적으로, 인터페이스 이름은 (예를 들어, <code>Readable</code>과 같은)형용사나 형용사구가 대신할 수도 있습니다.</p>

<h4 id="naming-method-names">6.2.3 메서드 이름</h4>

<p>메서드 이름은 <code>lowerCamelCase</code>로 작성됩니다. Private 메서드의 이름은 끝에 언더스코어를 붙여서 끝내야 합니다.</p>

<p>메서드 이름은 주로 동사나 동사구입니다. 예를 들어, <code>sendMessage</code> 또는 <code>stop_</code>가 있습니다. 프로퍼티를 위한 Getter와 Setter 메서드는 전혀 필요치 않지만, 만약 사용되면 <code>getFoo</code>(또는 불리언에 대해 선택적으로 <code>isFoo</code> 혹은 <code>hasFoo</code>), 또는 Setter에는 <code>setFoo(value)</code>로 명명돼야 합니다.</p>

<p>또한 언더스코어는 JsUnit 테스트 메서드에서 이름의 논리적인 컴포넌트를 구분하기 위해 나타날 수도 있습니다. 한 가지 전형적인 패턴은 <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>입니다. 예를 들어 <code>testPop_emptyStack</code>. 테스트 메서드 명명에 한 가지 정해진 방법은 없습니다.</p>

<h4 id="naming-enum-names">6.2.4 열거형(enum) 이름</h4>

<p>열거형의 이름은 클래스와 비슷하게, <code>UpperCamelCase</code>로 작성되며, 일반적으로 단수 명사입니다. 열거형 내의 각 아이템은 <code>CONSTANT_CASE</code>로 명명됩니다.</p>

<h4 id="naming-constant-names">6.2.5 상수 이름</h4>

<p>상수 이름은 <code>CONSTANT_CASE</code>를 사용합니다. 모두 대문자이며, 각 단어는 언더스코어로 구분됩니다. private static 프로퍼티는 (암시적으로 private인)모듈 지역으로 대체될 수 있기 때문에, 상수 이름 끝에 언더스코어를 붙일 이유는 없습니다.</p>

<h5 id="naming-definition-of-constant">6.2.5.1 &#8220;상수&#8221;의 정의</h5>

<p>모든 상수는 <code>@const</code> 정적 프로퍼티이거나 모듈의 로컬 <code>const</code> 선언이지만, 모든 <code>@const</code> 정적 프로퍼티와 모듈의 로컬 <code>const</code>가 상수는 아닙니다. 상수 사례를 선택하기 전에, 필드가 <em>깊은 불변</em>(deeply immutable) 상수인지 고려하십시오. 예를 들어 어떤 인스턴스의 관측 가능한 상태는 바뀔 수 있으며, 거의 확실히 상수가 아닙니다. 객체를 절대 변형하지 않는 것을 의도하는 것만으로는 충분하지 않습니다. </p>

<p>Examples:</p>

<pre><code class="language-js prettyprint">// Constants
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// Not constants
let letVariable = 'non-const';
class MyClass { constructor() { /** @const */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';
const /** Set&lt;String&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // mirrors imported name
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>

<p>상수 이름은 주로 명사 또는 명사구입니다.</p>

<h5 id="naming-local-aliases">6.2.5.1 지역 변수 별칭(local alias)</h5>

<p>지역 변수 별칭은 완전히 갖춰진 이름보다 가독성을 높일 때마다 사용돼야 합니다. 원래 이름의 마지막 부분을 유지하는 <code>goog.require</code>(<a href="#file-goog-require">??</a>)와 동일한 규칙을 따릅니다. 별칭은 함수 안에서도 사용될 수 있습니다. 별칭은 <code>const</code>여야 합니다.</p>

<p>Examples:</p>

<pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code></pre>

<h4 id="naming-non-constant-field-names">6.2.6 비 상수 필드 이름</h4>

<p>상수가 아닌 필드 이름은 (static든 아니든) private 필드에는 끝에 언더스코어를 붙여서, <code>lowerCamelCase</code>로 작성됩니다.</p>

<p>이 이름들은 주로 명사 또는 명사구입니다. 예를 들어 <code>computedValues</code> 또는 <code>index_</code></p>

<h4 id="naming-parameter-names">6.2.7 파라미터 이름</h4>

<p>파라미터 이름은 <code>lowerCamelCase</code>로 작성됩니다. 이는 파라미터가 생성자인 경우에도 적용된다는 것을 알아두세요.</p>

<p>1 글자인 파라미터 이름은 public 메서드에서는 사용되선 안됩니다.</p>

<p><strong>예외</strong>: 서드 파티 프레임워크에 필요한 경우, 파라미터 이름은 <code>$</code>으로 시작할 수도 있습니다. 이 예외는 다른 식별자(e.g., 지역 변수, 프로퍼티)에는 적용하지 않습니다.</p>

<h4 id="naming-local-variable-names">6.2.8 지역 변수 이름</h4>

<p>위에 기술된 대로 모듈 지역 (최상위)상수를 제외하고, 지역 변수 이름은 <code>lowerCamelCase</code>로 작성됩니다. 함수 범위의 상수는 여전히 <code>lowerCamelCase</code>로 명명됩니다. lowerCamelCase는 변수가 생성자를 가진 경우에도 적용한다는 것을 알아두세요.</p>

<h4 id="naming-template-parameter-names">6.2.9 템플릿 파라미터 이름</h4>

<p>템플릿 파라미터 이름은 <code>TYPE</code> 또는 <code>THIS</code>와 같이 간결하고, 한 단어이거나 한 글자 식별자이면서 모두 대문자여야 합니다.</p>

<h3 id="naming-camel-case-defined">6.3 낙타 표기법: 정의됨</h3>

<p>두문자(acronym)나 <q>IPv6</q> 또는 <q>iOS</q> 처럼, 때로는 영어 구절l(phrase)을 낙타 표기법으로 바꾸는 둘 이상의 합리적인 방법이 있습니다. 예측 가능성을 높이기 위해 구글 스타일은 다음의 (거의) 결정적인 스키마를 명시합니다.</p>

<p>이름의 산문 형식으로 시작:</p>

<ol>
  <li>구절을 평문 ASCII로 변환하고 아포스트로피를 제거합니다. 예를 들어,
    <q>M&#252;ller&apos;s algorithm</q>은 <q>Muellers algorithm</q>이 될 수 있습니다.
  </li>
  <li>공백이나 남아있는 구두점(주로 하이픈)으로 잘라 단어들로 나눕니다.
    <ol>
      <li>Recommended: 단어가 일반적인 사용 방식에서 관례적인 낙타 표기법의 외형을 띤다면, 요소 성분(e.g., <q>AdWords</q>는 <q>ad words</q>)으로 자릅니다. <q>iOS</q>와 같은 다는어는 그 자레초는 진짜 낙타 표기법이 아님을 명심하십시오. 이는 어떤 관례에도 어긋나기 때문에, 이 권장사항은 적용하지 않습니다.</li>
    </ol>
  </li>
  <li>(두문자어를 포함하여) 전부 소문자로 바꿉니다, 그 후 다음의 첫 번째 글자를 대문자로 바꿉니다:
    <ol>
      <li>&#8230; upper camel case가 될 각각의 단어, 또는</li>
      <li>&#8230; lower camel case가 될, 첫 번째를 제외한 각 단어</li>
    </ol>
  </li>
  <li>마지막으로, 모든 단어를 하나의 식별자로 합칩니다.</li>
</ol>
<ol>

<p>원래 단어의 대소문자 표기는 거의 모두 무시된다는 것을 알아두십시오.</p>

<p>Examples:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Prose form</th>
<th style="text-align: center">Correct</th>
<th style="text-align: center">Incorrect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center"><q>XML HTTP request</q></td>
<td style="text-align: center">XmlHttpRequest</td>
<td style="text-align: center">XMLHTTPRequest</td>
</tr>
<tr>
<td style="text-align: center"><q>new customer ID</q></td>
<td style="text-align: center">newCustomerId</td>
<td style="text-align: center">newCustomerID</td>
</tr>
<tr>
<td style="text-align: center"><q>inner stopwatch</q></td>
<td style="text-align: center">innerStopwatch</td>
<td style="text-align: center">innerStopWatch</td>
</tr>
<tr>
<td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
<td style="text-align: center">supportsIpv6OnIos</td>
<td style="text-align: center">supportsIPv6OnIOS</td>
</tr>
<tr>
<td style="text-align: center"><q>YouTube importer</q></td>
<td style="text-align: center">YouTubeImporter</td>
<td style="text-align: center">YoutubeImporter*</td>
</tr>
</tbody>
</table>

<p>*가능하지만 권장되지는 않음.</p>

<p>Note: 영어에서 특정 단어는 모호하게 하이픈으로 연결돼 있습니다: 예를 들어 <q>nonempty</q>와 <q>non-empty</q>는 둘 다 맞습니다, 때문에 메서드 이름 checkNonempty와 checkNonEmpty는 둘 다 맞습니다.</p>

<h2 id="jsdoc">7 JSDoc</h2>

<p><a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">JSDoc</a>은 모든 클래스, 필드, 메서드에 사용됩니다.</p>

<h3 id="jsdoc-general-form">7.1 일반적인 형식</h3>

<p>JSDoc 블럭의 기본적인 형식은 다음과 같습니다:</p>

<pre><code class="language-js prettyprint">/**
 * 여러 줄의 JSDoc 텍스트는 이곳에 작성됩니다,
 * 줄 평범하게 줄바꿈됩니다.
 * @param {number} 뭔가 하는 인자 A.
 */
function doSomething(arg) { &#8230; }
</code></pre>

<p>또는 한 줄로 작성된 예시:</p>

<pre><code class="language-js prettyprint">/** @const @private {!Foo} A short bit of JSDoc. */
this.foo_ = foo;
</code></pre>

<p>단일 행 주석이 여러 줄로 넘어가면, 해당 줄에 <code>/**</code>와 <code>*/</code>를 사용하여 다중 행 주석으로 바뀌어야 합니다.</p>

<p>많은 도구들이 코드 유효성 검사와 초기화를 위해 JSDoc 주석으로부터 메타데이터를 추출합니다. 때문에, 이런 주석들은 형식을 잘 <strong>갖춰야 합니다</strong></p>

<h3 id="jsdoc-markdown">7.2 마크다운</h3>

<p>JSDoc은 마크다운으로 작성되긴 하지만, 필요한 경우 HTML을 포함할 수도 있습니다. </p>

<p>JSDoc을 자동으로 추출하는 도구들(e.g. <a href="https://github.com/jleyba/js-dossier">JsDossier</a>)은 종종 평문 형식을 무시하기도 한다는 것을 기억하십시오. 만약 다음과 같은 경우:</p>

<pre><code class="language-js prettyprint badcode">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code></pre>

<p>다음과 같이 나올 것입니다:</p>

<pre><code>Computes weight based on three factors: items sent items received last timestamp
</code></pre>

<p>대신, 마크다운 리스트로 작성하세요:</p>

<pre><code class="language-js prettyprint">/**
 * Computes weight based on three factors:
 *  - items sent
 *  - items received
 *  - last timestamp
 */
</code></pre>

<h3 id="jsdoc-tags">7.3 JSDoc 태그</h3>

<p>구글 스타일은 JSDoc 태그의 서브셋을 허용합니다. 전체 목록은 <a href="#appendices-jsdoc-tag-reference">??</a>에서 보시기 바랍니다. 대부분의 태그는 줄의 시작에 태그와 함께 각자 고유한 공간을 차지해야 합니다.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
</code></pre>

<p>(<code>@private</code>, <code>@const</code>, <code>@final</code>, <code>@export</code>와 같은)추가적인 데이터가 필요하지 않은 단순한 태그들은 적절한 상황에서 옵션 유형과 함께 같은 라인에 결합될 수도 있습니다.</p>

<pre><code class="language-js prettyprint">/**
 * Place more complex annotations (like "implements" and "template")
 * on their own lines.  Multiple simple tags (like "export" and "final")
 * may be combined in one line.
 * @export @final
 * @implements {Iterable&lt;TYPE&gt;}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Some object.
   * @param {number=} num An optional number.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array&lt;!ObjType|number&gt;} */
    this.data_ = [obj, num];
  }
}
</code></pre>

<p>태그들을 결합할 때나 결합 순서에 엄격한 규칙은 없지만, 일관되게 유지하십시오.</p>

<p>JavaScript에서 표기 유형에 관한 일반적인 정보는 <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a>와 <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
 System</a>을 참고하시기 바랍니다.</p>

<h3 id="jsdoc-line-wrapping">7.4 Line wrapping</h3>

<p>Line-wrapped block tags are indented four spaces.  Wrapped description text may
be lined up with the description on previous lines, but this horizontal
alignment is discouraged.</p>

<pre><code class="language-js prettyprint">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
exports.method = function(foo) {
  return 5;
};
</code></pre>

<p>Do not indent when wrapping a <code>@fileoverview</code> description.</p>

<h3 id="jsdoc-top-file-level-comments">7.5 Top/file-level comments</h3>

<p>A file may have a top-level file overview. A copyright notice , author information, and
default <a href="#jsdoc-visibility-annotations">visibility level</a> are optional.  File overviews are generally recommended whenever a
file consists of more than a single class definition. The top level comment is
designed to orient readers unfamiliar with the code to what is in this file. If
present, it may provide a description of the file's contents and any
dependencies or compatibility information. Wrapped lines are not indented.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @package
 */
</code></pre>

<h3 id="jsdoc-class-comments">7.6 Class comments</h3>

<p>Classes, interfaces and records must be documented with a description and any
template parameters, implemented interfaces, visibility, or other appropriate
tags. The class description should provide the reader with enough information to
know how and when to use the class, as well as any additional considerations
necessary to correctly use the class. Textual descriptions may be omitted on the
constructor. <code>@constructor</code> and <code>@extends</code> annotations are not used with the
<code>class</code> keyword unless the class is being used to declare an <code>@interface</code> or
it extends a generic class.</p>

<pre><code class="language-js prettyprint">/**
 * A fancier event target that does cool things.
 * @implements {Iterable&lt;string&gt;}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 An argument that makes this more interesting.
   * @param {!Array&lt;number&gt;} arg2 List of numbers to be processed.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Records are also helpful.
 * @extends {Iterator&lt;TYPE&gt;}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} The next item in line to be returned. */
  next() {}
}
</code></pre>

<h3 id="jsdoc-enum-and-typedef-comments">7.7 Enum and typedef comments</h3>

<p>Enums and typedefs must be documented.  Public enums and typedefs must have a
non-empty description.  Individual enum items may be documented with a JSDoc
comment on the preceding line.</p>

<pre><code class="language-js prettyprint">/**
 * A useful type union, which is reused often.
 * @typedef {!Bandersnatch|!BandersnatchType}
 */
let CoolUnionType;


/**
 * Types of bandersnatches.
 * @enum {string}
 */
const BandersnatchType = {
  /** This kind is really frumious. */
  FRUMIOUS: 'frumious',
  /** The less-frumious kind. */
  MANXOME: 'manxome',
};
</code></pre>

<p>Typedefs are useful for defining short record types, or aliases for unions,
complex functions, or generic types.
Typedefs should be avoided for record types with many fields, since they do not
allow documenting individual fields, nor using templates or recursive
references.
For large record types, prefer <code>@record</code>.</p>

<h3 id="jsdoc-method-and-function-comments">7.8 Method and function comments</h3>

<p>Parameter and return types must be documented. The <code>this</code> type should be
documented when necessary. Method, parameter, and return descriptions (but not
types) may be omitted if they are obvious from the rest of the method&#8217;s JSDoc or
from its signature. Method descriptions should start with a sentence written in
the third person declarative voice.  If a method overrides a superclass method,
it must include an <code>@override</code> annotation.  Overridden methods must include all
<code>@param</code> and <code>@return</code> annotations if any types are refined, but should omit
them if the types are all the same.</p>

<pre><code class="language-js prettyprint">/** This is a class. */
class SomeClass extends SomeBaseClass {
  /**
   * Operates on an instance of MyClass and returns something.
   * @param {!MyClass} obj An object that for some reason needs detailed
   *     explanation that spans multiple lines.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Whether something occurred.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /** @override */
  overriddenMethod(param) { ... }
}

/**
 * Demonstrates how top-level functions follow the same rules.  This one
 * makes an array.
 * @param {TYPE} arg
 * @return {!Array&lt;TYPE&gt;}
 * @template TYPE
 */
function makeArray(arg) { ... }
</code></pre>



<p>Anonymous functions do not require JSDoc, though parameter types may be specified inline if the automatic type inference is insufficient.</p>

<pre><code class="language-js prettyprint">promise.then(
    (/** !Array&lt;number|string&gt; */ items) =&gt; {
      doSomethingWith(items);
      return /** @type {string} */ (items[0]);
    });
</code></pre>

<h3 id="jsdoc-property-comments">7.9 Property comments</h3>

<p>Property types must be documented. The description may be omitted for private
properties, if name and type provide enough documentation for understanding the
code.</p>

<p>Publicly exported constants are commented the same way as properties.  Explicit
types may be omitted for <code>@const</code> properties initialized from an expression with
an obviously known type.</p>

<p>Tip: A <code>@const</code> property&#8217;s type can be considered &#8220;obviously known&#8221; if it is
assigned directly from a constructor parameter with a declared type, or directly
from a function call with a declared return type.  Non-const properties and
properties assigned from more complex expressions should have their types
declared explicitly.</p>

<pre><code class="language-js prettyprint">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Maximum number of things per pane.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * The number of times we'll try before giving up.
 * @const
 */
MyClass.RETRY_COUNT = 33;
</code></pre>

<h3 id="jsdoc-type-annotations">7.10 Type annotations</h3>

<p>Type annotations are found on <code>@param</code>, <code>@return</code>, <code>@this</code>, and <code>@type</code> tags,
and optionally on <code>@const</code>, <code>@export</code>, and any visibility tags.  Type
annotations attached to JSDoc tags must always be enclosed in braces.</p>

<h4 id="jsdoc-nullability">7.10.1 Nullability</h4>

<p>The type system defines modifiers <code>!</code> and <code>?</code> for non-null and nullable,
respectively.  Primitive types (<code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>,
<code>symbol</code>, and <code>function(...): ...</code>) and record literals (<code>{foo: string, bar:
number}</code>) are non-null by default.  Do not add an explicit <code>!</code> to these types.
Object types (<code>Array</code>, <code>Element</code>, <code>MyClass</code>, etc) are nullable by default, but
cannot be immediately distinguished from a name that is <code>@typedef</code>&#8217;d to a
non-null-by-default type.  As such, all types except primitives and record
literals must be annotated explicitly with either <code>?</code> or <code>!</code> to indicate whether
they are nullable or not.</p>

<h4 id="jsdoc-type-casts">7.10.2 Type Casts</h4>

<p>In cases where type checking doesn't accurately infer the type of an expression,
it is possible to tighten the type by adding a type annotation comment and
enclosing the expression in parentheses. Note that the parentheses are required.</p>

<pre><code class="language-js prettyprint">/** @type {number} */ (x)
</code></pre>

<h4 id="jsdoc-template-parameter-types">7.10.3 Template Parameter Types</h4>

<p>Always specify template parameters. This way compiler can do a better job and it
makes it easier for readers to understand what code does.</p>

<p>Bad:</p>

<pre><code class="language-js prettyprint badcode">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;
</code></pre>

<p>Good:</p>

<pre><code class="language-js prettyprint">const /** !Object&lt;string, !User&gt; */ users = {};
const /** !Array&lt;string&gt; */ books = [];
const /** !Promise&lt;!Response&gt; */ response = ...;

const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object&lt;string, *&gt; */ mapOfEverything = {};
</code></pre>

<p>Cases when template parameters should not be used:</p>

<ul>
<li><code>Object</code> is used for type hierarchy and not as map-like structure.</li>
</ul>

<h3 id="jsdoc-visibility-annotations">7.11 Visibility annotations</h3>

<p>Visibility annotations (<code>@private</code>, <code>@package</code>, <code>@protected</code>) may be specified
in a <code>@fileoverview</code> block, or on any exported symbol or property.  Do not
specify visibility for local variables, whether within a function or at the top
level of a module.  All <code>@private</code> names must end with an underscore.</p>

<h2 id="policies">8 Policies</h2>

<h3 id="policies-be-consistent">8.1 Issues unspecified by Google Style: Be Consistent!</h3>

<p>For any style question that isn't settled definitively by this specification,
prefer to do what the other code in the same file is already doing. If that
doesn't resolve the question, consider emulating the other files in the same
package.</p>

<h3 id="policies-compiler-warnings">8.2 Compiler warnings</h3>

<h4 id="policies-use-a-standard-warning-set">8.2.1 Use a standard warning set</h4>

<p>
As far as possible projects should use <code>--warning_level=VERBOSE</code>.
</p>

<h4 id="policies-how-to-handle-a-warning">8.2.2 How to handle a warning</h4>

<p>Before doing anything, make sure you understand exactly what the warning is
telling you. If you're not positive why a warning is appearing, ask for help
.</p>

<p>Once you understand the warning, attempt the following solutions in order:</p>

<ol>
<li><strong>First, fix it or work around it.</strong> Make a strong attempt to actually
address the warning, or find another way to accomplish the task that avoids
the situation entirely.</li>
<li><strong>Otherwise, determine if it's a false alarm.</strong> If you are convinced that
the warning is invalid and that the code is actually safe and correct, add a
comment to convince the reader of this fact and apply the <code>@suppress</code>
annotation.</li>
<li><strong>Otherwise, leave a TODO comment.</strong> This is a <strong>last resort</strong>.  If you do
this, <strong>do not suppress the warning.</strong> The warning should be visible until
it can be taken care of properly.</li>
</ol>

<h4 id="policies-suppress-a-warning-at-the-narrowest-reasonable-scope">8.2.3 Suppress a warning at the narrowest reasonable scope</h4>

<p>Warnings are suppressed at the narrowest reasonable scope, usually that of a single local variable or very small method. Often a variable or method is extracted for that reason alone.</p>

<p>Example</p>

<pre><code class="language-js prettyprint">/** @suppress {uselessCode} Unrecognized 'use asm' declaration */
function fn() {
  'use asm';
  return 0;
}
</code></pre>

<p>Even a large number of suppressions in a class is still better than blinding the
entire class to this type of warning.</p>

<h3 id="policies-deprecation">8.3 Deprecation</h3>

<p>Mark deprecated methods, classes or interfaces with <code>@deprecated</code> annotations. A
deprecation comment must include simple, clear directions for people to fix
their call sites.</p>

<h3 id="policies-code-not-in-google-style">8.4 Code not in Google Style</h3>

<p>You will occasionally encounter files in your codebase that are not in proper
Google Style. These may have come from an acquisition, or may have been written
before Google Style took a position on some issue, or may be in non-Google Style
for any other reason.</p>

<h4 id="policies-reformatting-existing-code">8.4.1 Reformatting existing code</h4>

<p>When updating the style of existing code, follow these guidelines.</p>

<ol>
<li>It is not required to change all existing code to meet current style
guidelines.  Reformatting existing code is a trade-off between code churn
and consistency. Style rules evolve over time and these kinds of tweaks to
maintain compliance would create unnecessary churn.  However, if significant
changes are being made to a file it is expected that the file will be in
Google Style.</li>
<li>Be careful not to allow opportunistic style fixes to muddle the focus of a
CL. If you find yourself making a lot of style changes that aren&#8217;t critical
to the central focus of a CL, promote those changes to a separate CL.</li>
</ol>

<h4 id="policies-newly-added-code-use-google-style">8.4.2 Newly added code: use Google Style</h4>

<p>Brand new files use Google Style, regardless of the style choices of other files
in the same package.</p>

<p>When adding new code to a file that is not in Google Style, reformatting the
existing code first is recommended, subject to the advice in
<a href="#policies-reformatting-existing-code">??</a>.</p>

<p>If this reformatting is not done, then new code should be as consistent as
possible with existing code in the same file, but must not violate the style
guide.</p>

<h3 id="policies-local-style-rules">8.5 Local style rules</h3>

<p>Teams and projects may adopt additional style rules beyond those in this
document, but must accept that cleanup changes may not abide by these additional
rules, and must not block such cleanup changes due to violating any additional
rules. Beware of excessive rules which serve no purpose. The style guide does
not seek to define style in every possible scenario and neither should you.</p>

<h3 id="policies-generated-code-mostly-exempt">8.6 Generated code: mostly exempt</h3>

<p>Source code generated by the build process is not required to be in Google
Style. However, any generated identifiers that will be referenced from
hand-written source code must follow the naming requirements. As a special
exception, such identifiers are allowed to contain underscores, which may help
to avoid conflicts with hand-written identifiers.</p>

<h2 id="appendices">9 Appendices</h2>

<h3 id="appendices-jsdoc-tag-reference">9.1 JSDoc tag reference</h3>

<p>JSDoc serves multiple purposes in JavaScript.  In addition to being used to
generate documentation it is also used to control tooling.  The best known are
the Closure Compiler type annotations.</p>

<h4 id="appendices-type-annotations">9.1.1 Type annotations and other Closure Compiler annotations</h4>

<p>Documentation for JSDoc used by the Closure Compiler is described in
<a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a> and <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
System</a>.</p>

<h4 id="appendices-documentation-annotations">9.1.2 Documentation annotations</h4>

<p>In addition to the JSDoc described in <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure
Compiler</a> the following tags are common and well supported by various
documentation generations tools (such as <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) for purely documentation
purposes.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@author</code> or <code>@owner</code>
      </td><td><code>@author username@google.com (First Last)</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Utilities for handling textareas.
 * @author <a href="mailto:kuth@google.com">kuth@google.com</a> (Uthur Pendragon)
 */
 </pre>
      </td><td>Document the author of a file or the owner of a test, generally only
        used in the <code>@fileoverview</code> comment. The <code>@owner</code> tag is used by the
        unit test dashboard to determine who owns the test results.
        <p>Not recommended.
    </p></td></tr><tr>
      <td><code>@bug</code>
      </td><td><code>@bug bugnumber</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @bug 1234567 */
function testSomething() {
  // &#8230;
}

<p>/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // &#8230;
}
</p></pre>
      </td><td>Indicates what bugs the given test function regression tests.
        <p>Multiple bugs should each have their own <code>@bug</code> line, to make
        searching for regression tests as easy as possible.
    </p></td></tr><tr>
      <td><code>@code</code>
      </td><td><code>{@code ...}</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Moves to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it
 * passes the end of the range.
 * @return {!Node} The node at the next position.
 */
goog.dom.RangeIterator.prototype.next = function() {
  // &#8230;
};
</pre>
      </td><td>Indicates that a term in a JSDoc description is code so it may be
        correctly formatted in generated documentation.
    </td></tr><tr>
      <td><code>@see</code>
      </td><td><code>@see Link</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */
 </pre>
       </td><td>Reference a lookup to another class function or method.
    </td></tr><tr>
      <td><code>@supported</code>
      </td><td><code>@supported Description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the
 * browsers' event systems.
 * @supported IE10+, Chrome, Safari
 */
</pre>
      </td><td>Used in a fileoverview to indicate what browsers are supported by
        the file.
    </td></tr><tr>
      <td><code>@desc</code>
      </td><td><code>@desc Message description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @desc Notifying a user that their account has been created. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Your account has been successfully created.');
 </pre>
      </td></tr></tbody></table></p>

<p>You may also see other types of JSDoc annotations in third-party code. These
annotations appear in the <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc Toolkit Tag Reference</a> but are not considered
part of valid Google style.</p>

<h4 id="appendices-framework-specific-annotations">9.1.3 Framework specific annotations</h4>

<p>The following annotations are specific to a particular framework.
<table>
  <thead>
    <tr>
      <th>Framework
      </th><th>Tag
      </th><th>Documentation
  </th></tr></thead><tbody>
    <tr>
      <td>Angular 1
      </td><td><code>@ngInject</code>
      </td></tr><tr>
      <td>Polymer
      </td><td><code>@polymerBehavior</code>
      </td><td>
          
            <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass">https://github.com/google/closure-compiler/wiki/Polymer-Pass</a>
          
    </td></tr></tbody></table></p>

<h4 id="appendices-notes-about-standard-closure-compiler-annotations">9.1.4 Notes about standard Closure Compiler annotations</h4>

<p>The following tags used to be standard but are now deprecated.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@expose</code>
      </td><td><code>@expose</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@export</code> and/or <code>@nocollapse</code>
        instead.</strong>
    </td></tr><tr>
      <td><code>@inheritDoc</code>
      </td><td><code>@inheritDoc</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@override</code> instead.</strong>
</td></tr></tbody></table></p>

<h3 id="appendices-commonly-misunderstood-style-rules">9.2 Commonly misunderstood style rules</h3>

<p>Here is a collection of lesser-known or commonly misunderstood facts about
Google Style for JavaScript. (The following are true statements; this is not a
list of <q>myths.</q>)</p>

<ul>
<li>Neither a copyright statement nor <code>@author</code> credit is required in a source
file. (Neither is explicitly recommended, either.)</li>
<li>Aside from the constructor coming first
(<a href="#features-classes-constructors">??</a>), there is no <q>hard and fast</q> rule
governing how to order the members of a class (<a href="#features-classes">??</a>).</li>
<li>Empty blocks can usually be represented concisely as <code>{}</code>, as detailed in
(<a href="#formatting-empty-blocks">??</a>).</li>
<li>The prime directive of line-wrapping is: prefer to break at a higher
syntactic level (<a href="#formatting-where-to-break">??</a>).</li>
<li>Non-ASCII characters are allowed in string literals, comments and Javadoc,
and in fact are recommended when they make the code easier to read than the
equivalent Unicode escape would (<a href="#non-ascii-characters">??</a>).</li>
</ul>

<h3 id="appendices-style-related-tools">9.3 Style-related tools</h3>

<p>The following tools exist to support various aspects of Google Style.</p>

<h4 id="appendices-tools-closure-compiler">9.3.1 Closure Compiler</h4>

<p>This program performs type checking and other checks,
optimizations and other transformations (such as ECMAScript 6 to ECMAScript 5
code lowering).</p>

<h4 id="appendices-clang-format">9.3.2 <code>clang-format</code></h4>

<p>This program  reformats
JavaScript source code into Google Style, and also follows a number of
non-required but frequently readability-enhancing formatting practices.</p>

<p><code>clang-format</code> is not required. Authors are allowed to change its output, and
reviewers are allowed to ask for such changes; disputes are worked out in the
usual way. However, subtrees may choose to opt in to such enforcement locally.</p>

<h4 id="appendices-closure-compiler-linter">9.3.3 Closure compiler linter</h4>

<p>This program  checks for a
variety of missteps and anti-patterns.
</p>

<h4 id="appendices-conformance-framework">9.3.4 Conformance framework</h4>

<p>The JS Conformance Framework is a tool that is part of the Closure Compiler that
provides developers a simple means to specify a set of additional checks to be
run against their code base above the standard checks.  Conformance checks can,
for example, forbid access to a certain property, or calls to a certain
function, or missing type information (unknowns).</p>

<p>These rules are commonly used to enforce critical restrictions (such as defining
globals, which could break the codebase) and security patterns (such as using
<code>eval</code> or assigning to <code>innerHTML</code>), or more loosely to improve code quality.</p>

<p>For additional information see the official documentation for the
<a href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework">JS Conformance Framework</a>.</p>

<h3 id="appendices-legacy-exceptions">9.4 Exceptions for legacy platforms</h3>

<h4 id="appendices-legacy-exceptions-overview">9.4.1 Overview</h4>

<p>This section describes exceptions and additional rules to be followed when
modern ECMAScript 6 syntax is not available to the code authors. Exceptions to
the recommended style are required when ECMAScript 6 syntax is not possible and
are outlined here:</p>

<ul>
<li>Use of <code>var</code> declarations is allowed</li>
<li>Use of <code>arguments</code> is allowed</li>
<li>Optional parameters without default values are allowed</li>
</ul>

<h4 id="appendices-legacy-exceptions-var">9.4.2 Use <code>var</code></h4>

<h5 id="appendices-legacy-exceptions-var-scope">9.4.2.1 <code>var</code> declarations are NOT block-scoped</h5>

<p><code>var</code> declarations are scoped to the beginning of the nearest enclosing
function, script or module, which can cause unexpected behavior, especially with
function closures that reference <code>var</code> declarations inside of loops. The
following code gives an example:</p>

<pre><code class="language-js prettyprint badcode">for (var i = 0; i &lt; 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// logs 2, 2, 2 -- NOT 0, 1, 2
// because `iteration` is function-scoped, not local to the loop.

</code></pre>

<h5 id="appendices-legacy-exceptions-var-declare">9.4.2.2 Declare variables as close as possible to first use</h5>

<p>Even though <code>var</code> declarations are scoped to the beginning of the enclosing
function, <code>var</code> declarations should be as close as possible to their first use,
for readability purposes. However, do not put a <code>var</code> declaration inside a block
if that variable is referenced outside the block. For example:</p>

<pre><code class="language-js prettyprint">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" could be declared here, but don't do that.
    count++;
  }
  console.log(count + ' items in y');
}
</code></pre>

<h5 id="appendices-legacy-exceptions-var-const">9.4.2.3 Use @const for constants variables</h5>

<p>For global declarations where the <code>const</code> keyword would be used, if it were
available, annotate the <code>var</code> declaration with @const instead (this is optional
for local variables).</p>

<h4 id="appendices-legacy-exceptions-function">9.4.3 Do not use block scoped functions declarations</h4>

<p>Do <strong>not</strong> do this:</p>

<pre><code class="language-js prettyprint badcode">if (x) {
  function foo() {}
}
</code></pre>

<p>While most JavaScript VMs implemented before ECMAScript 6 support function
declarations within blocks it was not standardized. Implementations were
inconsistent with each other and with the now-standard ECMAScript 6 behavior for
block scoped function declaration. ECMAScript 5 and prior only allow for
function declarations in the root statement list of a script or function and
explicitly ban them in block scopes in strict mode.</p>

<p>To get consistent behavior, instead use a <code>var</code> initialized with a function
expression to define a function within a block:</p>

<pre><code class="language-js prettyprint">if (x) {
  var foo = function() {};
}
</code></pre>

<h4 id="appendices-legacy-exceptions-goog-provide">9.4.4 Dependency management with <code>goog.provide</code>/<code>goog.require</code></h4>

<p><strong><code>goog.provide</code> is deprecated. All new files should use <code>goog.module</code>, even in
projects with existing <code>goog.provide</code> usage. The following rules are for
pre-existing goog.provide files, only.</strong></p>

<h5 id="appendices-legacy-exceptions-goog-provide-summary">9.4.4.1 Summary</h5>

<ul>
<li>Place all <code>goog.provide</code>s first, <code>goog.require</code>s second. Separate provides
from requires with an empty line.</li>
<li>Sort the entries alphabetically (uppercase first).</li>
<li>Don't wrap <code>goog.provide</code> and <code>goog.require</code> statements. Exceed 80 columns
if necessary.</li>
<li>Only provide top-level symbols.</li>
</ul>

<p>As of Oct 2016, <strong><code>goog.provide</code>/<code>goog.require</code> dependency management is
deprecated</strong>. All new files, even in projects using <code>goog.provide</code> for older
files, should use
<a href="#source-file-structure"><code>goog.module</code></a>.</p>

<p><code>goog.provide</code> statements should be grouped together and placed first. All
<code>goog.require</code> statements should follow. The two lists should be separated with
an empty line.</p>

<p>Similar to import statements in other languages, <code>goog.provide</code> and
<code>goog.require</code> statements should be written in a single line, even if they
exceed the 80 column line length limit.</p>

<p>The lines should be sorted alphabetically, with uppercase letters coming first:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');

</code></pre>

<p>All members defined on a class should be in the same file. Only top-level
classes should be provided in a file that contains multiple members defined on
the same class (e.g. enums, inner classes, etc).</p>

<p>Do this:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
</code></pre>

<p>Not this:</p>

<pre><code class="language-js prettyprint badcode">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code></pre>

<p>Members on namespaces may also be provided:</p>

<pre><code class="language-js prettyprint">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');
</code></pre>

<h5 id="appendices-legacy-exceptions-goog-scope">9.4.4.2 Aliasing with <code>goog.scope</code></h5>

<p><strong><code>goog.scope</code> is deprecated. New files should not use <code>goog.scope</code> even in
projects with existing goog.scope usage.</strong></p>

<p><code>goog.scope</code> may be used to shorten references to namespaced symbols in
code using <code>goog.provide</code>/<code>goog.require</code> dependency management.</p>

<p>Only one <code>goog.scope</code> invocation may be added per file. Always place it in
the global scope.</p>

<p>The opening <code>goog.scope(function() {</code> invocation must be preceded by exactly one
blank line and follow any <code>goog.provide</code> statements, <code>goog.require</code> statements,
or top-level comments. The invocation must be closed on the last line in the
file. Append <code>// goog.scope</code> to the closing statement of the scope. Separate the
comment from the semicolon by two spaces.</p>

<p>Similar to C++ namespaces, do not indent under <code>goog.scope</code> declarations.
Instead, continue from the 0 column.</p>

<p>Only make aliases for names that will not be re-assigned to another object
(e.g., most constructors, enums, and namespaces). Do not do this (see below for
how to alias a constructor):</p>

<pre><code class="language-js prettyprint badcode">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...
</code></pre>

<p>Names must be the same as the last property of the global that they are aliasing.</p>

<pre><code class="language-js prettyprint">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Alias new types after the constructor declaration.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Declare methods on the prototype as usual:
SomeType.prototype.findButton = function() {
  // Button as aliased above.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code></pre>

</div>
</body>
</html>

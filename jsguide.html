<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Google JavaScript Style Guide</title>
<link rel="stylesheet" href="javaguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico">
<script src="include/jsguide.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google JavaScript Style Guide</h1>
<h2 id="introduction">1 소개</h2>

<p>이 문서는 Javascript 프로그래밍 언어로 작성된 코드에 대한 구글의 코딩 표준의 <strong>완전한</strong> 정의 역할을 합니다. Javascript 소스 파일은 이 문서의 규칙을 따라야 <em>구글 스타일로</em>표시됩니다.</p>

<p>다른 프로그래밍 스타일 가이드처럼, 서식의 미적인 문제 뿐만 아니라, 다른 
유형이나 코딩 표준에 대한 문제도 다뤄집니다. 하지만, 이 문서는 우선적으로 범용적으로 따르는 명확한 규칙들에 집중하고, (직접 하든 도구를 사용하든) 명확하게 따를 수 없는 조언들은 피합니다. </p>

<h3 id="terminology-notes">1.1 용어 노트</h3>

<p>이 문서에서는 별도로 명시되지 않는 한, 다음을 따릅니다:</p>

<ol>
<li><p><em>주석</em>은 항상 <em>구현</em> 주석을 의미합니다. <q>문서화
주석</q>이라는 용어는 사용하지 않으며, 대신 <code>/** &#8230; */</code>안에
위치한 사람이 읽을 수 있는 문자와 기계가 읽을 수 있는 어노테이션에 대해
&#8220;JSDoc&#8221;을 공통 용어로 사용합니다. </p></li>
<li><p>이 스타일 가이드는 <em>해야 한다</em>, <em>해서는 안된다</em>, <em>하는 것이 좋다</em>, <em>하지 않는 것이 좋다</em>, 그리고 <em>할 수 있다</em>로 표기할 때에는 <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a>의 용어를 사용합니다. <em>선호한다</em>와 <em>피한다</em>는 각각 <em>하는 것이 좋다</em>와 <em>하지 않는 것이 좋다</em>에 대응합니다. 명령적이고 선언적인 구문들은 <em>해야 한다</em>에 대응합니다.</p></li>
</ol>

<p>다른 <q>용어 노트</q>가 가끔 문서 중간에 나타날 것입니다.</p>

<h3 id="guide-notes">1.2 가이드 노트</h3>

<p>이 문서의 예시 코드는 <strong>비표준</strong>입니다. 즉, 예시들이 구글 스타일이어도 그 코드를 대표하는 <em>유일하게</em> 우아한 방법을 설명하는 것이 아닐 수 있습니다. 예시에서 사용된 선택 사항의 서식은 규칙으로서 강요되서는 안됩니다.</p>

<h2 id="source-file-basics">2 소스 파일 기본</h2>

<h3 id="file-name">2.1 파일명</h3>

<p>파일명은 모두 소문자이며 언더스코어(<code>_</code>) 혹은 대시(<code>-</code>)
를 포함할 수도 있지만, 다른 구두점은 사용할 수 없습니다. 프로젝트에서 사용하는 관례를 따르십시오. 파일명의 확장자는 <code>.js</code>여야 합니다.</p>

<h3 id="file-encoding">2.2 파일 인코딩: UTF-8</h3>

<p>소스 파일은 <strong>UTF-8</strong>로 인코딩됩니다.</p>

<h3 id="special-characters">2.3 특수 문자</h3>

<h4 id="whitespace-characters">2.3.1 공백 문자</h4>

<p>라인 종걸 시퀀스를 제외하고, ASCII 수평 공백 문자(0x20)만이 소스 파일 어느 곳에서나 나타나는 유일한 공백 문자입니다. 이는 다음을 의미합니다</p>

<ol>
<li><p>문자열 리터럴에 있는 모든 공백 문자는 이스케이프 되며,</p></li>
<li><p>탭 문자는 들여쓰기에 사용하지 <strong>않습니다</strong>.</p></li>
</ol>

<h4 id="special-escape-sequences">2.3.2 특수 이스케이프 시퀀스</h4>

<p>특수 이스케이프 시퀀스 (<code>\'</code>, <code>\"</code>, <code>\\</code>,
<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>,
<code>\t</code>, <code>\v</code>)를 가진 임의의 문자에 대해, 그 시퀀스는 대응되는 숫자 이스케이프 대신 사용됩니다 (e.g <code>\x0a</code>, <code>\u000a</code>, 혹은 <code>\u{a}</code>). 기존의 8진수 이스케이프는 절대 사용되지 않습니다.</p>

<h4 id="non-ascii-characters">2.3.3 Non ASCII 문자</h4>

<p>Non ASCII 문자를 남겨두기 위해서는, 어느 쪽이 코드를 더
<strong>읽고 이해하기 쉽게</strong> 만드는지에 따라 실제 유니코드 문자
(e.g. <code>&#8734;</code>) 혹은 동등한 16진수나 유니코드 이스케이프
(e.g. <code>\u221e</code>)가 사용됩니다.</p>

<p>팁: 유니코드 이스케이프를 사용하는 경우와, 심지어 실제 유니코드 문자를 사용하는 경우에도, 이를 설명하는 주석은 매우 유용할 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>Example
      </th><th>Discussion
  </th></tr></thead><tbody>
    <tr>
      <td><code class="prettyprint lang-js">const units = '&#956;s';</code>
      </td><td>Best: 주석이 없어도 완벽하게 깔끔합니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // '&#956;s'
        </code>
      </td><td>허용되지만, 이렇게 할 이유는 없습니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // Greek letter mu, 's'
        </code>
      </td><td>허용되지만, 어색하고 실수할 여지가 있습니다.
    </td></tr><tr>
      <td><code class="badcode">const units = '\u03bcs';</code>
      </td><td>Poor: 읽는 사람은 뭔지 전혀 모릅니다.
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">return '\ufeff' + content;  // byte order mark
        </code>
      </td><td>
        Good: 비 출력 문자를 위해 이스케이프를 사용하고, 필요한 경우 주석을 추가하십시오.
</td></tr></tbody></table>

<p>팁: 절대로 프로그램이 non ASCII 문자를 적절히 처리하지 못할 거라는 두려움 때문에 쉽게 코드의 가독성을 떨어뜨리지 마십시오. 만약 그런 일이 발생한다면, 그런 프로그램은 <strong>고장</strong>날 것이고, <strong>고쳐져</strong>야 합니다.</p>

<h2 id="source-file-structure">3 소스 파일 구조</h2>

<p>소스 파일은 다음 <strong>순서대로</strong> 구성됩니다:</p>

<ol>
<li>라이센스 혹은 저작권 정보(있는 경우)</li>
<li><code>@fileoverview</code> JSDoc(있는 경우)</li>
<li><code>goog.module</code>문</li>
<li><code>goog.require</code>문</li>
<li>파일의 구현부</li>
</ol>

<p>1개 혹은 2개의 빈 줄이 올 수 있는 파일의 구현부를 제외하고, <strong>정확히 하나의 빈 줄이</strong> 각 섹션을 구분합니다.</p>

<h3 id="file-copyright">3.1 라이센스 혹은 저작권 정보(있는 경우)</h3>

<p>파일에 라이센스 혹은 라이센스 정보가 들어가는 경우, 여기에 속합니다.</p>

<h3 id="file-fileoverview">3.2 <code>@fileoverview</code> JSDoc(있는 경우)</h3>

<p>서식 규칙에 대해서는 <a href="#jsdoc-top-file-level-comments">??</a>을 보시기 바랍니다.</p>

<h3 id="file-goog-module">3.3 <code>goog.module</code>문</h3>

<p>모든 파일은 한 줄에 정확히 하나의 <code>goog.module</code> 이름을 선언해야 합니다. <code>goog.module</code> 선언은 포장되선 안되며, 따라서 80자 제한에 예외로 합니다.</p>

<p>네임스페이스를 정의하는 것은 goog.module에 대한 전체 인자입니다. 이는 패키지 명(코드가 존재하는 디렉터리 구조의 조각을 반영한 식별자) + 선택적으로 패키지가 정의하는 메인 클래스/열거형/인터페이스를 끝에 연결합니다. The entire argument to goog.module is what defines a namespace.</p>

<p>예시</p>

<pre><code class="language-js prettyprint">goog.module('search.urlHistory.UrlHistoryService');
</code></pre>

<h4 id="naming-hierarchy">3.3.1 계층</h4>

<p>모듈 네임스페이스는 다른 모듈 네임스페이스의 <em>자식(direct child)</em>로 명명될 수 없습니다.</p>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">goog.module('foo.bar');   // 'foo.bar.qux' would be fine, though
goog.module('foo.bar.baz');
</code></pre>

<p>디렉터리 계층은 네임스페이스 계층을 반영하기 때문에, 더 깊게 중첩된 자식들은 더 높은 수준의 부모 디렉터리의 서브디렉터리입니다. &#8220;부모&#8221; 네임스페이스 그룹은 같은 디렉터리에 있게 된 순간부터 모든 자식 네임스페이스를 알고 있음을 의미한다는 것을 알아두십시오.</p>

<h4 id="file-set-test-only">3.3.2 <code>goog.setTestOnly</code></h4>

<p>하나의 <code>goog.module</code>문은 선택적으로 goog.setTestOnly() 호출에
따라올 수 있습니다.</p>

<h4 id="file-declare-legacy-namespace">3.3.3 <code>goog.module.declareLegacyNamespace</code></h4>

<p>하나의 <code>goog.module</code>문은
<code>goog.module.declareLegacyNamespace();</code> 호출에 따라올 수 있습니다.
가능하면<code>goog.module.declareLegacyNamespace()</code>은 피하십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();
</code></pre>

<p><code>goog.module.declareLegacyNamespace</code>은 기존의 객체 계층 기반 네임 스페이스로부터의 전환을 용이하게 하기 위해 존재하지만 몇 가지 명명에 제한이 있습니다. 자식 모듈 이름은 부모 네임스페이스 뒤에 생성되어야 하므로 이 이름은 <code>goog.module</code>의 하위 혹은 상위 이름이 될 수 없습니다(예를 들어, <code>goog.module('parent');</code> 와
<code>goog.module('parent.child');</code> 모두 안전하게 존재할 수 없으며,
<code>goog.module('parent');</code>와 <code>goog.module
('parent.child.grandchild');</code> 또한 마찬가지입니다).</p>

<h4 id="file-es6-modules">3.3.4 ES6 모듈</h4>

<p>의미가 아직 완전하지 않기 때문에, 아직은 (<code>export</code>와
<code>import</code> 키워드와 같은) ES6 모듈을 사용하지 마십시오. 의미가 완전히 표준이 되면 이 정책은 다시 한번 확인하시기 바랍니다.</p>

<h3 id="file-goog-require">3.4 <code>goog.require</code>문</h3>

<p>모듈 선언 직후 그룹화된 <code>goog.require</code>문으로
임포트를 수행합니다. 각 <code>goog.require</code>은 하나의 상수
볆명(alias)에 할당되거나, 여러 개의 상수 별칭으로 destructure
됩니다. 이러한 별칭은 코드는 타입 표기에서 <code>require</code>된
의존성을 참조할 수 있는 유일한 방법입니다. <code>goog.require</code>에 대한 인자를 제외하고 전체 이름은
사용되지 않습니다. 별칭 이름은 가능하면 임포트된 모듈의 마지막
점-구분 컴포넌트와 일치해야 합니다. 단, 차이를 분명히 구분해야
하거나 명확하게 가독성을 향상시키는 경우, 추가 컴포넌트가(올바르게
별칭의 타입을 구분하는 적절한 대소문자 구분으로) 포함될 수
있습니다. <code>goog.require</code>문은 이 파일 다른 곳에서는 등장하지 않을 수 있습니다.</p>

<p>만약 모듈이 부수 효과(side effect)만을 위해 임포트되었다면
할당이 생략될 수 있지만, 전체 이름이 파일의 다른 곳에 등장하지 않을 수 있습니다. 
주석은 이것이 왜 필요하고 컴파일러 경고를 무시해야 하는 지 설명하기 위해 필요합니다.</p>



<p>줄은 다음의 규칙에 따라 정렬됩니다. 왼쪽에 이름이 있는
(별칭에 할당되는) require가 첫 번째이며, 그 이름들에 따라 알파벳 순으로
정렬됩니다. 그 다음 destructure된 require가 다시 한번 왼쪽의 이름으로 정렬됩니다.
마지막으로, 임의의 단독 <code>goog.require</code> 호출이 위치합니다(일반적으로 이들은 오직 부수 효과만을 위해 임포트되는 모듈을 위한것입니다).</p>

<p>팁: 순서를 기억하고 정렬하는 일을 직접 할 필요는 없습니다. IDE가
올바르게 정렬되지 않은 require를 보고하도록 할 수 있습니다.</p>

<p>만약 긴 별칭 혹은 모듈 이름이 80자 제한을 초과한다면, 이는 포장되서는 <strong>안됩니다</strong>. goog.require 줄은 80자 제한에서 예외입니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">const MyClass = goog.require('some.package.MyClass');
const NsMyClass = goog.require('other.ns.MyClass');
const googAsserts = goog.require('goog.asserts');
const testingAsserts = goog.require('goog.testing.asserts');
const than80columns = goog.require('pretend.this.is.longer.than80columns');
const {clear, forEach, map} = goog.require('goog.array');
/** @suppress {extraRequire} Initializes MyFramework. */
goog.require('my.framework.initialization');
</code></pre>

<p>나쁜 예:</p>

<pre><code class="language-js badcode prettyprint">const randomName = goog.require('something.else'); // name must match

const {clear, forEach, map} = // don't break lines
    goog.require('goog.array');

function someFunction() {
  const alias = goog.require('my.long.name.alias'); // must be at top level
  // &#8230;
}
</code></pre>

<h4 id="file-goog-forward-declare">3.4.1 <code>goog.forwardDeclare</code></h4>

<p><code>goog.forwardDeclare</code>는 자주 필요하진 않지만 순환 의존석을 해제하거나 나중에 로드된 코드를 참조하는 데 유용한 도구입니다. 이러한 구문들은 그룹화되며 즉시 임의의 <code>goog.rquire</code>문을 따릅니다. <code>goog.forwardDeclare</code>문은 <code>goog.require</code>문과 동일한 스타일 규칙을 따릅니다.</p>

<h3 id="file-implementation">3.5 파일의 구현</h3>

<p>실질적인 구현은 모든 의존성 정보가 선언된 이후에 (적어도 하나의 빈 줄로 구분되어) 위치합니다.</p>

<p>이는 모듈-지역 선언(상수, 변수, 클래스, 함수, etc)에 더하여 임의의 익스포트 기호로 구성될 수 있습니다.</p>

<h2 id="formatting">4 서식</h2>

<p><strong>용어 노트</strong>: <em>유사 블럭 구조</em>는 클래스의 몸체, 함수, 메서드, 혹은 괄호로 구분된 코드 블럭을 나타냅니다. <a href="#features-array-literals">??</a>와 <a href="#features-object-literals">??</a>에 의해 임의의 배열 혹은 객체 리터럴이 선택적으로 유사 블럭 구조인 것 처럼 취급될 수 있습니다.</p>

<p>팁: <code>clang-format</code>(코드 자동 포맷팅 도구)을 사용하십시오. Javascript 커뮤니티는 clang-format이 Javascript 파일에서 <q>옳은 일을 하도록</q> 노력했습니다. <code>clang-format</code>은 몇몇 유명한 편집기와 통합됐습니다.</p>

<h3 id="formatting-braces">4.1 중괄호</h3>

<h4 id="formatting-braces-all">4.1.1 중괄호는 모든 제어 구조에 사용된다</h4>

<p>중괄호는 모든 제어 구조(i.e. <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> 등)에, 몸체가 단 한줄만을 포함하더라도 필요합니다. 비어 있지 않은 블럭의 첫 번째 문장(statement)는 새 줄에서 시작해야 합니다.</p>

<p>나쁜 예:</p>

<pre><code class="language-js badcode prettyprint">if (someVeryLongCondition())
  doSomething();

for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);
</code></pre>

<p><strong>예외</strong>: else가 없이, 포장되지 않은 채로 전체가 한 줄에
들어맞는 단순한 if문은 가독성을 높일 수 있는 경우 한 줄에 중괄호 없이 작성될 수
있습니다. 이는 제어 구조가 중괄호와 새 줄을 생략할 수 있는 유일한
경우입니다.</p>

<pre><code class="language-js prettyprint">if (shortCondition()) return;
</code></pre>

<h4 id="formatting-nonempty-blocks">4.1.2 비어있지 않은 블럭: K&amp;R 스타일</h4>

<p><em>비어있지 않은</em> 블럭과 유사 블럭 구조의 중괄호는 Kernighan and Ritchie 스타일(<q><a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a></q>)을 따릅니다:</p>

<ul>
<li>여는 중괄호 앞에서 개행하지 않습니다.</li>
<li>여는 중괄호 뒤에서 개행합니다.</li>
<li>닫는 중괄호 앞에서 개행합니다.</li>
<li><em>만약</em> 닫는 중괄호가 구문(statement) 혹은 함수나 클래스의 몸체 혹은
클래스 메서드 구문을 끝내는 경우 닫는 중괄호 뒤에서 개행합니다. 구체적으로,
<code>else</code>, <code>catch</code>, <code>while</code>, 혹은 쉽표, 세미콜론,
혹은 닫는 소괄호가 뒤에 따르는 경우, 개행하지 <em>않</em>습니다.</li>
</ul>

<p>예시:</p>

<pre><code class="language-js prettyprint">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code></pre>

<h4 id="formatting-empty-blocks">4.1.3 빈 블럭: 갈결할 수 있음</h4>

<p><em>다중 블럭 구문</em>(다중 블럭을 직접 포함하는 것: 
<code>if</code>/<code>else</code> 혹은
<code>try</code>/<code>catch</code>/<code>finally</code>)의 일부가
<em>아닌 이상</em>, 빈 블럭이나 유사 블럭 구조는 사이에 문자, 공백, 개행 없이
열린 즉시 닫힐 <em>수</em> 있습니다(즉, <code>{}</code>).</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">function doNothing() {}
</code></pre>

<p>나쁜 예:</p>

<pre><code class="language-js prettyprint badcode">if (condition) {
  // &#8230;
} else if (otherCondition) {} else {
  // &#8230;
}

try {
  // &#8230;
} catch (e) {}
</code></pre>

<h3 id="formatting-block-indentation">4.2 블럭 들여쓰기: +2 칸</h3>

<p>새 블럭 혹은 유사 블럭 구조가 열릴 때마다, 들여쓰기는 2칸 증가합니다.
블럭이 끝나면, 들여쓰기는 이전 들여쓰기 수준으로 돌아갑니다. 들여쓰기 수준은
블럭 내의 코드와 주석 양쪽에 적용합니다. (<a href="#formatting-nonempty-blocks">??</a>의 예시를 보세요).</p>

<h4 id="formatting-array-literals">4.2.1 배열 리터럴: 선택적으로 <q>유사 블럭 </q></h4>

<p>임의의 배열 리터럴은 &#8220;유사 블럭 구조&#8221;인 것 처럼 서식을 적용할 수 있습니다. 예를 들어, 다음은 모두 유효합니다(완전한 리스트는 <strong>아님</strong>):</p>

<pre><code class="language-js prettyprint columns">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code></pre>

<pre><code class="language-js prettyprint columns">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code></pre>

<p>특히 원소 간에 구문 그룹핑을 포함하여 다른 조합도 허용되지만, 단순히 큰 배열의 수직 크기를 줄이기 위해서 사용하지는 말아야 합니다.</p>

<h4 id="formatting-object-literals">4.2.2 객체 리터럴: 선택적으로 <q>유사 블럭</q></h4>

<p>임의의 객체 리터럴은 선택적으로 &#8220;유사 블럭 구조&#8221;인 것 처럼 서식을 적용할 수 있습니다. <a href="#formatting-array-literals">??</a>와 동일한 예시를 적용합니다. 예를 들어, 다음은 모두 유효합니다(완전한 리스트는 <strong>아님</strong>):</p>

<pre><code class="language-js prettyprint columns">const a = {
  a: 0,
  b: 1,
};

const b =
    {a: 0, b: 1};
</code></pre>

<pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code></pre>

<h4 id="formatting-class-literals">4.2.3 클래스 리터럴</h4>

<p>클래스 리터럴(선언이든 표현식이든)은 블럭으로써 들여쓰기됩니다. 메서드
끝이나 클래스 <em>선언</em>(할당(assignment)과 같이 클래스 <em>표현식</em>을
포함하는 구문은 여전히 세미콜론으로 끝납니다)의 닫는 중괄호에 세미콜론을
추가하지 마십시오. <code>extends</code> 키워드를 사용하되, 클래스가 템플릿화된 타입을 확장하는 것이 아니라면 <code>@extends</code> JSDoc 표기는 사용하지 마십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint columns">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
</code></pre>

<pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>

<h4 id="formatting-function-expressions">4.2.4 함수 표현식</h4>

<p>함수 호출의 인자 리스트에서 익명 함수를 선언할 때, 함수의 본문은 이전
들여쓰기 깊이보다 두 칸 더 들여쓰기됩니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) =&gt; {
      // Indent the function body +2 relative to the indentation depth
      // of the '.then()' call.
      if (result) {
        result.use();
      }
    });
</code></pre>

<h4 id="formatting-switch-statements">4.2.5 Switch문</h4>

<p>다른 블럭들과 마찬가지로, switch 블럭의 내용들은 +2 칸 들여쓰기됩니다.</p>



<p>switch 레이블 뒤에는 새 줄이 나타나며 블럭이 열릴 때 처럼 들여쓰기 수준은
2 칸 증가합니다. 렉시컬 스코핑에 필요한 경우 명시적인 블럭이 사용될 수
있습니다. 그 뒤에 따르는 switch 레이블은 블럭이 닫힐 때 처럼 이전 들여쓰기
수준으로 돌아갑니다.</p>

<p><code>break</code>와 그 다음 case 사이의 빈 줄은 선택사항입니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}
</code></pre>

<h3 id="formatting-statements">4.3 구문(statment)</h3>

<h4 id="formatting-one-statement-perline">4.3.1 한 줄에 한 구문 씩</h4>

<p>각 구문에는 개행이 뒤따릅니다.</p>

<h4 id="formatting-semicolons-are-required">4.3.2 세미콜론 필수</h4>

<p>모든 구문은 세미콜론으로 끝나야 합니다. 자동 세미콜론 삽입에 의존하는 것을 금합니다.</p>

<h3 id="formatting-column-limit">4.4 열 제한: 80자</h3>

<p>Javascript 코드는 80자의 열 제한을 갖습니다. 아래에 나열된 경우를 제외하고,
이를 초과하는 임의의 줄은 <a href="#formatting-line-wrapping">??</a>에 설명된
것 처럼 라인-포장되어야 합니다.</p>

<p><strong>예외:</strong></p>

<ol>
<li>열 제한을 따를 수 없는 라인 (예를 들어, JSDoc에서 복사-붙여넣기를 위한 긴 URL 혹은 쉘 명령).</li>
<li><code>goog.module</code>과 <code>goog.require</code> 구문 (<a href="#file-goog-module">??</a> 과
<a href="#file-goog-require">??</a> 참조).</li>
</ol>

<h3 id="formatting-line-wrapping">4.5 라인 포장</h3>

<p><strong>용어 노트</strong>: <em>줄 포장</em>은 하나의 표현식을 여러 줄로 나누는 것으로 정의됩니다.</p>

<p>매 상황에서의 줄 포장 방법을 <em>정확히</em> 보여주는 포괄적이고 결정적인 공식은 없습니다. 같은 코드 조각을 줄 포장하는 방법이 여러 가지인 경우가 매우 많습니다.</p>

<p>노트: 줄 포장을 사용하는 전형적인 이유는 열 제한을 초과하는 것을 피하기 위함이지만, 실제로 열 제한에 맞는 코드도 작성자의 재량에 따라 줄 포장될 수 있습니다.</p>

<p>팁: 메서드나 지역 변수를 추출해내는 것이 줄 포장할 필요 없이 문제를 해결할 수도 있습니다.</p>

<h4 id="formatting-where-to-break">4.5.1 개행 위치</h4>

<p>줄 포장의 주요 지시 사항은 <strong>더 높은 구문 수준</strong>에서 개행하는 것을 선호한다는 것입니다. </p>

<p>선호:</p>

<pre><code class="language-js prettyprint">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0f;
</code></pre>

<p>비선호:</p>

<pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0f;
</code></pre>

<p>앞선 예시에서, 가장 높은 구문 수준에서 가장 낮은 구문 수준은 다음과 같습니다: 할당, 나누기, 함수 호출, 매개변수, 숫자 상수.</p>

<p>연산자는 다음과 같이 래핑됩니다:</p>

<ol>
<li>줄이 연산자에서 바뀌는 경우 개행은 기호 다음에 옵니다. (이는 Java에 대한 Google 스타일과 다른 관례라는 점을 기억하십시오.)
<ol>
<li>이는 실질적으로 연산자가 아닌 <q>점</q>(<code>.</code>)에는 적용하지 않습니다.</li>
</ol></li>
<li>메서드 혹은 생성자 이름은 이에 따르는 여는 괄호(<code>(</code>)와 붙어 있습니다.</li>
<li>쉼표(<code>,</code>)는 이에 앞서는 토큰과 붙어 있습니다.</li>
</ol>

<blockquote>
<p>Note: 줄 포장의 우선 목표는 적은 줄에 불필요하게 코드를 맞추는 것이 아니라, 코드를 깔끔하게 하는 것입니다.</p>
</blockquote>

<h4 id="formatting-indent">4.5.2 이어지는 줄은 적어도 4 칸 들여쓸 것</h4>

<p>줄 포장시, 첫 번째 이후 각 줄(각 <em>이어지는 줄</em>)은 블럭 들여쓰기 규칙을 위반하지 않는 한, 처음 줄로부터 적어도 +4 칸 들여쓰기됩니다.</p>

<p>이어지는 줄이 여러 줄인 경우, 들여쓰기는 +4 칸 이상으로도 적절하게 변형될 수
있습니다. 일반적으로, 더 깊은 구문 수준에서 이어지는 줄은 4 칸보다 더
들여쓰기되며, 문법적으로 평행한(병렬적인) 원소로 시작하는 경우 두 줄은 같은
들여쓰기 수준을 사용합니다.</p>

<p><a href="#formatting-horizontal-alignment">??</a>은 특정 토큰을 이전 줄과 맞추기 위해 가변적인 수의 공백을 사용하는 좋지 않은 관례들을 다룹니다.</p>

<h3 id="formatting-whitespace">4.6 공백</h3>

<h4 id="formatting-vertical-whitespace">4.6.1 수직 공백</h4>

<p>하나의 빈 줄은 다음의 경우 나타납니다:</p>

<ol>
<li>연이은 메서드 혹은 객체 리터럴의 사이
<ol>
<li>예외: 객체 리터럴의 연이은 두 프로퍼티 사이(에 다른 코드 없이)의 빈 줄은 선택 사항입니다. 이러한 빈 줄은 필드의 <em>논리적 그룹</em>을 만드는 데 사용됩니다.</li>
</ol></li>
<li>메서드 본문에서, 구문의 논리적 그룹화를 위해.
함수 본문의 시작 혹은 끝의 빈 줄은 허용되지 않습니다.</li>
<li><em>선택적으로</em> 클래스 혹은 객체 리터럴에서 첫 메서드 앞이나 마지막 메서드의 뒤.</li>
<li>본 문서의 다른 섹션에서 요구되는 경우 (e.g.
<a href="#file-goog-require">??</a>).</li>
</ol>

<p><em>복수의</em> 연이은 빈 줄은 허용되지만 필수는 아닙니다.</p>

<h4 id="formatting-horizontal-whitespace">4.6.2 수평 공백</h4>

<p>수평 공백의 사용은 위치에 따라 다르며, 3개의 카테고리로 분류됩니다:
<em>앞서는 공백</em>(줄의 시작에), <em>따르는 공백</em>(줄의 끝에),
<em>내부 공백</em>. 앞서는 공백(i.e. 들여쓰기)은 다른 곳에서 다뤄집니다.
따르는 공백은 금지됩니다.</p>

<p>언어나 다른 스타일 규칙에 의해 요구되는 곳 외에, 리터럴, 주석, 그리고 JSDoc을 제외하고, 하나의 내부 ASCII 공백 또한 다음의 위치<strong>에만</strong> 나타납니다.</p>

<ol>
<li>줄에 뒤따르는 여는 괄호(<code>(</code>)와 임의의 (<code>if</code>, <code>for</code>, 혹은 <code>catch</code>와 같은)예약어를 구분.</li>
<li>줄에 앞서는 닫는 줄괄호(<code>}</code>)와 임의의 (<code>else</code> 혹은 <code>catch</code>와 같은)예약어를 구분. 여기에는 두 가지 예외가 있습니다:
<ol>
<li>함수의 첫 번째 인자 혹은 배열에서 첫 번째 원소인 객체 리터럴의 앞 (e.g. <code>foo({a: [{c: d}]})</code>).</li>
<li>템플릿 확장에서, 언어에 의해 금지된 경우
(e.g. <code>abc${1 + 2}def</code>).</li>
</ol></li>
<li>임의의 이항 혹은 삼항 연산자의 양쪽.</li>
<li>쉼표(<code>,</code>) 혹은 세미콜론(<code>;</code>) 뒤. 이러한 문자들 뒤에는 공백이 <em>절대</em> 허용되지 않는다는 것을 기억하십시오.</li>
<li>객체 리터럴에서 콜론(<code>:</code>) 뒤.</li>
<li>줄 끝의 주석이 시작되는 더블 슬래시(<code>//</code>)의 양쪽. 이곳에는 여러 개의 공백이 허용되지만, 반드시는 아닙니다.</li>
<li>JSDoc 주석의 여는 문자 뒤와 닫는 문자의 양쪽
(e.g. 타입 선언이나 형변환의 단형(short-form)에: <code>this.foo = /** @type
{number} */ (bar);</code> or <code>function(/** string */ foo) {</code>).</li>
</ol>

<h4 id="formatting-horizontal-alignment">4.6.3 수평 정렬: 권장하지 않음</h4>

<p><strong>용어 노트</strong>: <em>수평 정렬</em>이란 특정 토큰을 이전 라인의 다른 토큰 바로 아래에 위치하도록 코드에 가변적인 숫자의 공백을 추가하는 관례를
말합니다.</p>

<p>이 관례는 허용되지만, 구글 스타일에서는 <strong>일반적으로 권장되지 않습니다</strong>. 이미 수평 정렬이 사용된 곳에서 이를 <em>유지</em>할 필요도 없습니다.</p>

<p>정렬을 사용하지 않는 예시와 사용하는 예시가 있는데, 둘 다 허용되지만 후자는 권장되지 않습니다:</p>

<pre><code class="language-js prettyprint">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};
</code></pre>

<p>팁: 정렬은 가독성에 도움이 될 수 있지만, 이후의 유지보수에 문제를 만듭니다.
이후에 단 한줄만 건드렸을 때의 변화를 생각해보세요. 이 변화는 이전까지 맞춰져
있던 서식을 훼손할 수 있으며, 이는 허용됩니다.
이는 코드 작성자(아마도 여러분)에게 더 자주 근처 라인의 공백도 조정하도록 할
것이고, 서식을 다시 맞추는 작업을 연쇄적으로 발생시킬 수도 있습니다.
단 한줄의 변화가 이제는 <q>폭발 반경(blast radius)</q>을 갖게 되었습니다.
이는 최악의 경우 의미없이 바쁘기만 한 업무가 될 수 있습니다, 하지만 최선의
경우에도 버전 히스토리 정보를 손상시키고, 코드 리뷰어의 업무를
둔화(slows down)시키며 머지 충돌도 악화시킵니다.</p>

<h4 id="formatting-function-arguments">4.6.4 함수 인자</h4>

<p>모든 함수 인자를 함수 이름과 같은 줄에 넣으려고 하는 것이 좋습니다. 만약 80제한을 초과하려 한다면, 인자들은 읽기 좋은 형태로 줄 포장되어야 합니다. 공간을 절약하기 위해, 가능한 한 80자에 가깝게 포장하거나, 가독성을 향상시키기 위해 각 인자를 줄마다 넣을 수도 있습니다. 들여쓰기는 4 칸이어야 합니다. 괄호에 맞추는 것도 허용되지만 권장사항은 아닙니다. 아래는 인자 포장의 가장 흔한 패턴입니다:</p>

<pre><code class="language-js prettyprint">// Arguments start on a new line, indented four spaces. Preferred when the
// arguments don't fit on the same line with the function name (or the keyword
// "function") but fit entirely on the second line. Works with very long
// function names, survives renaming without reindenting, low on space.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // &#8230;
}

// If the argument list is longer, wrap at 80. Uses less vertical space,
// but violates the rectangle rule and is thus not recommended.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // &#8230;
}

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // &#8230;
}
</code></pre>

<h3 id="formatting-grouping-parentheses">4.7 그룹화 하는 괄호: 권장</h3>

<p>선택적으로 그룹화하는 괄호는 코드 작성자와 리뷰어가 괄호 없이도 코드가 잘못
해석될 여지가 없거나 읽기 더 쉽도록 한다는 데에 동의하는 경우에만 생략될 수
있습니다. 코드를 읽는 모든 이가 연산자 우선순위 표를 기억하고 있다고 가정하는
것은 합리적이지 <em>않</em>습니다.</p>

<p>다음과 같은 전체 표현식에 불필요한 괄호를 사용하지 마십시오:
<code>delete</code>, <code>typeof</code>, <code>void</code>, <code>return</code>, <code>throw</code>, <code>case</code>, <code>in</code>, <code>of</code>, 혹은 <code>yield</code>.</p>

<p>괄호는 형 변환에 필요합니다: <code>/** @type {!Foo} */ (foo)</code>.</p>

<h3 id="formatting-comments">4.8 주석</h3>

<p>이 섹션에서는 <em>구현 주석</em>을 다룹니다. JSDoc은 <a href="#jsdoc">??</a>에서 별도로 다뤄집니다..</p>

<h4 id="formatting-block-comment-style">4.8.1 블럭 주석 스타일</h4>

<p>블럭 주석은 둘러싼 코드와 같은 수준으로 들여쓰기됩니다.
<code>/* &#8230; */</code> 혹은 <code>//</code>-스타일이 될 수 있습니다.
다중 행<code>/* &#8230; */</code> 주석에서, 주석을 명확하게 하기 위해
그 다음 줄은 이전 줄의 <code>*</code>와 맞춰진 *로 시작해야 합니다.
&#8220;매개변수명&#8221; 형태의 주석은 값과 메서드명이 의미를 충분히 전달하지 못하는 경우 언제든 나타납니다.</p>

<pre><code class="language-js prettyprint">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code></pre>

<p>주석은 별표나 다른 문자로 그려진 상자로 둘러싸이지 않습니다.</p>

<p>JSDoc(<code>/** &#8230; */</code>)을 위와 같은 구현 주석에 사용하지 마십시오.</p>

<h2 id="language-features">5 언어의 특징</h2>

<p>Javascript는 많은 의심스러운(또한 위험하기도 한) 특징들을 포함합니다. 이
섹션은 사용되거나 사용되지 않을 수도 있는 특징들과 이들의 사용에 있어서
추가적인 제약 사항들을 기술합니다.</p>

<h3 id="features-local-variable-declarations">5.1 지역 변수 선언</h3>

<h4 id="features-use-const-and-let">5.1.1 <code>const</code>와 <code>let</code> 사용</h4>

<p>모든 지역 변수는 <code>const</code> 혹은 <code>let</code>과 함께 선언하십시오. 변수가 재할당 될 필요가 없는 한, 기본적으로 const를 사용하십시오. The <code class="badcode">var</code>
키워드는 사용되서는 안됩니다.</p>

<h4 id="features-one-variable-per-declaration">5.1.2 선언 당 하나의 변수</h4>

<p>모든 지역 변수 선언은 하나의 변수만을 선언합니다. <code class="badcode">let a = 1, b = 2;</code>와 같은 선언은 사용되지 않습니다.</p>

<h4 id="features-declared-when-needed">5.1.3 필요할때 선언, 가능한 빨리 초기화</h4>

<p>지역 변수는 습관적으로 이를 포함하는 블럭 혹은 유사 블럭 구조의 시작에서 선언되지 <strong>않</strong>습니다. 대신, 스코프를 최소화하기 위해 지역 변수는 이들이 처음으로 (필요에 맞게)사용되는 지점에서 가까운 곳에 선언됩니다.</p>

<h4 id="features-declare-types-as-needed">5.1.4 타입은 필요에 따라 선언</h4>

<p>JSDoc 타입 어노테이션은 선언의 윗줄 아니면 변수명 앞에 추가될 수 있씁니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];

/** @type {!Array&lt;number&gt;} */
const data = [];
</code></pre>

<p>팁: 컴파일러가 템플릿화된 타입은 추론할 수 있지만 매개변수는 그렇지 않은
경우가 많습니다. 이는 특히 리터럴 혹은 생성자 호출 초기화가 템플릿 매개변수의 타입(e.g. empty arrays, object, <code>Map</code>, 혹은 <code>Set</code>)에 대한 어떠한 값도 포함하지 않거나 변수가 클로저에서 수정된 경우에 그렇습니다. 그렇지 않으면 컴파일러는 템플릿 매개변수를 알 수 없는 것으로 추론하기 때문에 지역 변수 타입 어노테이션은 특히 이런 경우에 유용합니다.</p>

<h3 id="features-array-literals">5.2 배열 리터럴</h3>

<h4 id="features-arrays-trailing-comma">5.2.1 뒤따르는 쉼표를 사용할 것</h4>



<p>마지막 원소와 닫는 대괄호 사이에 개행이 있더라도 뒤따르는 쉼표를 포함하십시오.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">const values = [
  'first value',
  'second value',
];
</code></pre>

<h4 id="features-arrays-ctor">5.2.2 가변 <code>Array</code> 생성자를 사용하지 말 것</h4>

<p>이 생성자는 인자가 추가되거나 제거되면 오류가 발생하기 쉽습니다. 대신 리터럴을 사용하십시오.</p>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code></pre>

<p>세 번째 경우를 제외하고는 예상대로 동작합니다: 만약 <code>x1</code>이 정수이면 <code>a3</code>는 <code>x1</code>의 사이즈이면서 모든 원소가 <code>undefined</code>인 배열이 됩니다. 만약 <code>x1</code>이 다른 숫자이면 예외가 던져질 것이고, 임의의 다른 타입이면 단일 원소 배열이 될 것입니다.</p>

<p>대신, 다음과 같이 씁니다</p>

<pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code></pre>

<p><code> new Array(length)</code>를 사용하여 명시적으로 주어진 길이의 배열을 할당하는 것은 적절한 경우에만 허용됩니다.</p>

<h4 id="features-arrays-non-numeric-properties">5.2.3 숫자가 아닌 프로퍼티</h4>

<p>배열에 (<code>length</code> 이외에)숫자가 아닌 프로퍼티를 정의하거나 사용하지 마십시오. 대신 <code>Map</code> (혹은 <code>Object</code>)를 사용하십시오.</p>

<h4 id="features-arrays-destructuring">5.2.4 비구조화(Destructuring)</h4>

<p>배열 리터럴은 (단일 배열이나 순회 가능한 객체로부터 여러 개의 값을 가져오는것과 같은)비구조화 할당의 왼쪽에서 사용될 수 있습니다. 마지막 <q>나머지</q> 원소가 (<code>...</code>와 변수명 사이에 공백 없이)포함될 수 있습니다. 원소가 사용되지 않는 경우에는 생략되어야 합니다.</p>

<pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code></pre>

<p>비구조화는 함수 매개변수에서도 사용될 수 있습니다 (매개변수 이름은 필요하지만 무시된다는 점을 기억하십시오). 비구조화된 배열 매개변수가 선택 사항이라면, 항상 <code>[]</code>를 기본값으로 명시하고, 왼쪽에 기본값을 제공하십시오:</p>

<pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };
</code></pre>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };
</code></pre>

<p>팁: 여러 값을 함수의 매개변수 혹은 반환값으로 전달할 때는, 개개의 원소에 명명이 가능하고 각각 다른 타입을 명시할 수 있기 때문에 가능하면 배열 비구조화보다 객체 비구조화를 선호하십시오.</p>

<h4 id="features-arrays-spread-operator">5.2.5 전개 연산자</h4>

<p>배열 리터럴은 하나 이상의 다른 순회 가능한(iterable) 객체에서 원소들을 평평하게(faltten) 하기 위해 전개 연산자(<code>...</code>)를 포함할 수도 있습니다. 전개 연산자는 <code>Array.prototype</code>을 사용하는 더 어색한 구문 대신에 사용되어야 합니다. <code>...</code> 뒤에는 공백이 없습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">[...foo]   // preferred over Array.prototype.slice.call(foo)
[...foo, ...bar]   // preferred over foo.concat(bar)
</code></pre>

<h3 id="features-object-literals">5.3 객체 리터럴</h3>

<h4 id="features-objects-use-trailing-comma">5.3.1 뒤따르는 쉼표를 사용할 것</h4>

<p>마지막 프로퍼티와 닫는 중괄호 사이에 개행이 있을 때마다 쉼표를 포함합니다.</p>

<h4 id="features-objects-ctor">5.3.2 <code>Object</code> 생성자 사용하지 말 것</h4>

<p><code>Object</code>가 <code>Array</code>와 동일한 문제를 갖고 있진 않더라도, 일관성을 위해 허용되지 않습니다. 대신 객체 리터럴(<code>{}</code> 혹은 <code>{a: 0, b: 1, c: 2}</code>)을 사용하십시오.</p>

<h4 id="features-objects-mixing-keys">5.3.3 따옴표로 감싼 키와 감싸지 않은 키를 혼용하지 말 것</h4>

<p>객체 리터럴은 (따옴표로 감싸지 않은 키 및 또는 기호로)<em>구조</em> 혹은
(따옴표로 감싸고 혹은 계산된 키값으로)<em>사전(dicts)</em>을 나타낼 수 있습니다. 하나의 객체 리터럴에 이러한 키 유형을 혼용하지 마십시오.</p>

<p>좋지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">{
  a: 42, // struct-style unquoted key
  'b': 43, // dict-style quoted key
}
</code></pre>

<h4 id="features-objects-computed-property-names">5.3.4 계산된 프로퍼티 이름</h4>

<p>계산된 프로퍼티 이름(e.g., <code>{['key' + foo()]: 42}</code>)는 허용되며,
계산된 프로퍼티가 기호(e.g., <code>[Symbol.iterator]</code>)가 아닌 한,
사전 스타일 (따옴표를 사용하는) 키로 간주됩니다(즉, 따옴표를 사용하지 않는 키와
혼용돼서는 안됩니다).
열거 값 또한 계산된 키에 사용될 수 있습니다, 하지만 같은 리터럴에서 비-열거형 키와 혼용되서는 안됩니다.</p>

<h4 id="features-objects-method-shorthand">5.3.5 메서드 축약</h4>

<p>메서드는 객체 리터럴에서 바로 뒤에 <code>function</code>이나 화살표 함수 리터럴이 있는 대신 메서드 축약을 사용하여 정의될 수 있습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
</code></pre>

<p>화살표 함수에서 <code>this</code>가 객체 리터럴 외부의 스코프를 참조하는
것과 달리, 메서드 축약이나 <code>function</code>에서 <code>this</code>는
객체 리터럴 자체를 참조한다는 점을 알아두십시오.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () =&gt; this.stuff,  // Returns 'fruit'
    };
  }
}
</code></pre>

<h4 id="features-objects-shorthand-properties">5.3.6 프로퍼티 축약</h4>

<p>프로퍼티 축약은 객체 리터럴에서 허용됩니다.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code></pre>

<h4 id="features-objects-destructuring">5.3.7 비구조화</h4>

<p>객체 비구조화 패턴은 하나의 객체로부터 여러 값을 비구조화하여 풀어내기 위해 할당의 왼쪽에서 사용될 수 있습니다.</p>

<p>비구조화된 객체는 또한 함수 매개변수로도 사용될 수 있지만, 단일 수준의
따옴표를 사용하지 않은 축약형 프로퍼티로 가능한 한 단순하게 유지되어야 합니다.
더 깊은 수준의 중첩과 계산된 프로퍼티는 매개변수 비구조화에서 사용되지 않을 수
있습니다. 비구조화된 매개변수(<code class="badcode">{str} = {str: 'some default'}</code> 보다는 <code>{str = 'some default'} = {}</code>와 같이)의 왼쪽에 임의의 기본값을 명시하고, 만약 비구조화된 객체 자체가 선택적이라면 기본값은 <code>{}</code>여야 합니다. 비구조화된 파라미터에 대한 JSDoc은 어떤 이름(이름은 사용되지 않지만 컴파일러에 의해 필요합니다)이라도 될 수 있습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {})
</code></pre>

<p>옳지 않은 예:</p>

<pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code></pre>

<p>비구조화는 <code>goog.require</code>에서도 쓰일 수 있으며, 이 경우 포장되서는 안되며 전체 구문은 길이에 관계 없이 한 줄을 차지해야 합니다(<a href="#file-goog-require">??</a>을 참고하십시오). </p>

<h4 id="features-objects-enums">5.3.8 열거형</h4>

<p>열거형은 객체 리터럴에 <code>@enum</code> 애노테이션을 추가함으로써 정의됩니다.
정의된 이후에는 추가적인 프로퍼티가 추가되지 않을 수 있습니다. 열거형은 상수여야 하며, 모든 열거 값은 깊은 불변(deeply immutable) 객체여야 합니다.</p>

<pre><code class="language-js prettyprint">/**
 * Supported temperature scales.
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * An enum with two options.
 * @enum {number}
 */
const Option = {
  /** The option used shall have been the first. */
  FIRST_OPTION: 1,
  /** The second among two options. */
  SECOND_OPTION: 2,
};
</code></pre>

<h3 id="features-classes">5.4 클래스</h3>

<h4 id="features-classes-constructors">5.4.1 생성자</h4>

<p>구체 클래스(concrete class)에 대한 생성자는 선택사항입니다. 서브클래스 생성자는 <code>this</code> 접근으로 필드 등을 설정하기 전에 <code>super()</code>를 호출해야 합니다. 인터페이스는 생성자를 정의해선 안됩니다.</p>

<h4 id="features-classes-fields">5.4.2 필드</h4>

<p>모든 구체 클래스의 필드(i.e. 메서드 외의 모든 프로퍼티)를 생성자에서
설정하십시오. 다시 재할당 되지 않는 필드는 <code>@const</code>로 표기하십시오
(깊은 불변일 필요는 없습니다). Private 필드는 <code>@private</code>으로
표기되어야 하며 이들의 이름은 언더스코어로 끝나야 합니다. 필드는 절대 구체 클래스의 <code>prototype</code>에 설정하지 않습니다.</p>

<p>예시:</p>

<pre><code class="language-js prettyprint">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();
  }
}
</code></pre>

<p>팁: VM의 최적화 능력을 상당히 저해하기 때문에 생성자가 종료된 후에
프로퍼티는 절대로 인스턴스에 추가되거나 제거되어서는 안됩니다. 만약 필요한 경우,
나중에 초기화될 필드는 이후의 형태 변화를 방지하기 위해 생성자에서 명시적으로
<code>undefined</code>로 설정되어야 합니다. 객체에 <code>@struct</code>를
추가하면 선언되지 않은 프로퍼티가 추가/접근되는지 검사합니다. 클래스는
기본적으로 추가됩니다.</p>

<h4 id="features-classes-computed-properties">5.4.3 계산된 프로퍼티</h4>



<p>계산된 프로퍼티는 클래스에서 프로퍼티가 기호인 경우에만 사용될 수 있습니다. 
사전 스타일 프로퍼티(<a href="#features-objects-mixing-keys">??</a>에 정의된 
대로, 이는 따옴표로 감싸거나 계산된 비 기호 키를 말합니다)는 허용되지 않습니다.
<code>[Symbol.iterator]</code> 메서드는 논리적으로 순회 가능한 임의의 
클래스에서 정의되어야 합니다. 이외에 <code>Symbol</code>은 적게 사용해야 
합니다.</p>

<p>팁: 임의의 다른 내장 기호(e.g. <code>Symbol.isConcatSpreadable</code>) 사용에 주의하십시오. 이들은 컴파일러에서 폴리필되지 않으므로 구형 브라우저에서는 동작하지 않을 것입니다.</p>

<h4 id="features-classes-static-methods">5.4.4 Static methods</h4>



<p>Where it does not interfere with readability, prefer module-local functions over
private static methods.</p>

<p>Static methods should only be called on the base class itself. Static methods
should not be called on variables containing a dynamic instance that may be
either the constructor or a subclass constructor (and must be defined with
<code>@nocollapse</code> if this is done), and must not be called directly on a subclass
that doesn&#8217;t define the method itself.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // discouraged: don't call static methods dynamically
Sub.foo();  // illegal: don't call static methods on subclasses that don't define it themselves
</code></pre>

<h4 id="features-classes-old-style">5.4.5 Old-style class declarations</h4>

<p>While ES6 classes are preferred, there are cases where ES6 classes may not be
feasible.  For example:</p>

<ol>
<li><p>If there exist or will exist subclasses, including frameworks that create
subclasses, that cannot be immediately changed to use ES6 class syntax. If
such a class were to use ES6 syntax, all downstream subclasses not using ES6
class syntax would need to be modified.</p></li>
<li><p>Frameworks that require a known <code>this</code> value before calling the superclass
constructor, since constructors with ES6 super classes do not have
access to the instance <code>this</code> value until the call to <code>super</code> returns.</p></li>
</ol>

<p>In all other ways the style guide still applies to this code: <code>let</code>, <code>const</code>,
default parameters, rest, and arrow functions should all be used when
appropriate.</p>

<p><code>goog.defineClass</code> allows for a class-like definition similar to ES6 class
syntax:</p>

<pre><code class="language-javascript">let C = goog.defineClass(S, {
  /**
   * @param {string} value
   */
  constructor(value) {
    S.call(this, 2);
    /** @const */
    this.prop = value;
  },

  /**
   * @param {string} param
   * @return {number}
   */
  method(param) {
    return 0;
  },
});
</code></pre>

<p>Alternatively, while <code>goog.defineClass</code> should be preferred for all new code,
more traditional syntax is also allowed.</p>

<pre><code class="language-javascript">/**
  * @constructor @extends {S}
  * @param {string} value
  */
function C(value) {
  S.call(this, 2);
  /** @const */
  this.prop = value;
}
goog.inherits(C, S);

/**
 * @param {string} param
 * @return {number}
 */
C.prototype.method = function(param) {
  return 0;
};
</code></pre>

<p>Per-instance properties should be defined in the constructor after the call to the super class constructor, if there is a super class.  Methods should be defined on the prototype of the constructor.</p>

<p>Defining constructor prototype hierarchies correctly is harder than it first appears!  For that reason, it is best to use <code>goog.inherits</code> from <a href="http://code.google.com/closure/library/">the Closure Library </a>.</p>

<h4 id="features-classes-prototypes">5.4.6 Do not manipulate <code>prototype</code>s directly</h4>

<p>The <code>class</code> keyword allows clearer and more readable class definitions than
defining <code>prototype</code> properties. Ordinary implementation code has no business
manipulating these objects, though they are still useful for defining <code>@record</code>
interfaces and classes as defined in <a href="#features-classes-old-style">??</a>. Mixins
and modifying the prototypes of builtin objects are
explicitly forbidden.</p>

<p><strong>Exception</strong>: Framework code (such as Polymer, or Angular) may need to use <code>prototype</code>s, and should not
resort to even-worse workarounds to avoid doing so.</p>

<p><strong>Exception</strong>: Defining fields in interfaces (see <a href="#features-classes-interfaces">??</a>).</p>

<h4 id="features-classes-getters-and-setters">5.4.7 Getters and Setters</h4>

<p>Do not use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">JavaScript getter and setter properties</a>.  They are potentially
surprising and difficult to reason about, and have limited support in the
compiler.  Provide ordinary methods instead.</p>

<p><strong>Exception</strong>: when working with data binding frameworks (such as Angular and
Polymer), getters and setters may be used sparingly.  Note, however, that
compiler support is limited.  When they are used, they must be defined either
with <code>get foo()</code> and <code>set foo(value)</code> in the class or object literal, or if that
is not possible, with <code>Object.defineProperties</code>.  Do not use
<code>Object.defineProperty</code>, which interferes with property renaming.  Getters
<strong>must not</strong> change observable state.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">class Foo {
  get next() { return this.nextId++; }
}
</code></pre>

<h4 id="features-classes-overriding-tostring">5.4.8 Overriding toString</h4>

<p>The <code>toString</code> method may be overridden, but must always succeed and never have
visible side effects.</p>

<p>Tip: Beware, in particular, of calling other methods from toString, since
exceptional conditions could lead to infinite loops.</p>

<h4 id="features-classes-interfaces">5.4.9 Interfaces</h4>

<p>Interfaces may be declared with <code>@interface</code> or <code>@record</code>. Interfaces declared
with <code>@record</code> can be explicitly (i.e. via <code>@implements</code>) or implicitly
implemented by a class or object literal.</p>

<p>All non-static method bodies on an interface must be empty blocks.  Fields must
be defined after the interface body as stubs on the <code>prototype</code>.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

/** @type {number} The number of attempts before giving up. */
Frobnicator.prototype.attempts;
</code></pre>

<h3 id="features-functions">5.5 Functions</h3>

<h4 id="features-functions-top-level-functions">5.5.1 Top-level functions</h4>

<p>Exported functions may be defined directly on the <code>exports</code> object, or else
declared locally and exported separately.  Non-exported functions are encouraged
and should not be declared <code>@private</code>.</p>

<p>Examples:</p>

<pre><code class="language-js prettyprint">/** @return {number} */
function helperFunction() {
  return 42;
}
/** @return {number} */
function exportedFunction() {
  return helperFunction() * 2;
}
/**
 * @param {string} arg
 * @return {number}
 */
function anotherExportedFunction(arg) {
  return helperFunction() / arg.length;
}
/** @const */
exports = {exportedFunction, anotherExportedFunction};
</code></pre>

<pre><code class="language-js prettyprint">/** @param {string} arg */
exports.foo = (arg) =&gt; {
  // do some stuff ...
};
</code></pre>

<h4 id="features-functions-nested-functions">5.5.2 Nested functions and closures</h4>

<p>Functions may contain nested function definitions.  If it is useful to give the
function a name, it should be assigned to a local <code>const</code>.</p>

<h4 id="features-functions-arrow-functions">5.5.3 Arrow functions</h4>

<p>Arrow functions provide a concise syntax and fix a number of difficulties with
<code>this</code>.  Prefer arrow functions over the <code>function</code> keyword, particularly for
nested functions (but see <a href="#features-objects-method-shorthand">??</a>).</p>

<p>Prefer using arrow functions over <code>f.bind(this)</code>, and especially over
<code>goog.bind(f, this)</code>. Avoid writing <code>const self = this</code>. Arrow functions are
particularly useful for callbacks, which sometimes pass unexpected additional
arguments.</p>

<p>The right-hand side of the arrow may be a single expression or a block.
Parentheses around the arguments are optional if there is only a single
non-destructured argument.</p>

<p>Tip: It is a good practice to use parentheses even for single-argument arrows,
since the code may still parse reasonably (but incorrectly) if the parentheses
are forgotten when an additional argument is added.</p>

<h4 id="features-functions-generators">5.5.4 Generators</h4>

<p>Generators enable a number of useful abstractions and may be used as needed.</p>

<p>When defining generator functions, attach the <code>*</code> to the <code>function</code> keyword when
present, and separate it with a space from the name of the function.  When using
delegating yields, attach the <code>*</code> to the <code>yield</code> keyword.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
</code></pre>

<h4 id="features-functions-parameters">5.5.5 Parameters</h4>

<p>Function parameters must be typed with JSDoc annotations in the JSDoc preceding
the function&#8217;s definition, except in the case of same-signature <code>@override</code>s,
where all types are omitted.</p>

<p>Parameter types <em>may</em> be specified inline, immediately before the parameter name
(as in <code>(/** number */ foo, /** string */ bar) =&gt; foo + bar</code>). Inline and
<code>@param</code> type annotations <em>must not</em> be mixed in the same function definition.</p>

<h5 id="features-functions-default-parameters">5.5.5.1 Default parameters</h5>

<p>Optional parameters are permitted using the equals operator in the parameter
list. Optional parameters must include spaces on both sides of the equals
operator, be named exactly like required parameters (i.e., not prefixed with
<code>opt_</code>), use the <code>=</code> suffix in their JSDoc type, come after required parameters,
and not use initializers that produce observable side effects. All optional
parameters must have a default value in the function declaration, even if that
value is <code>undefined</code>.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} required This parameter is always needed.
 * @param {string=} optional This parameter can be omitted.
 * @param {!Node=} node Another optional parameter.
 */
function maybeDoSomething(required, optional = '', node = undefined) {}
</code></pre>

<p>Use default parameters sparingly. Prefer destructuring (as in
<a href="#features-objects-destructuring">??</a>) to create readable APIs when there
are more than a small handful of optional parameters that do not have a natural
order.</p>

<p>Note: Unlike Python's default parameters, it is okay to use initializers that
return new mutable objects (such as <code>{}</code> or <code>[]</code>) because the initializer is
evaluated each time the default value is used, so a single object won't be
shared across invocations.</p>

<p>Tip: While arbitrary expressions including function calls may be used as
initializers, these should be kept as simple as possible. Avoid initializers
that expose shared mutable state, as that can easily introduce unintended
coupling between function calls.</p>

<h5 id="features-functions-rest-parameters">5.5.5.2 Rest parameters</h5>

<p>Use a <em>rest</em> parameter instead of accessing <code>arguments</code>. Rest parameters are
typed with a <code>...</code> prefix in their JSDoc. The rest parameter must be the last
parameter in the list. There is no space between the <code>...</code> and the parameter
name.  Do not name the rest parameter <code>var_args</code>. Never name a local variable or
parameter <code>arguments</code>, which confusingly shadows the built-in name.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @param {!Array&lt;string&gt;} array This is an ordinary parameter.
 * @param {...number} numbers The remainder of arguments are all numbers.
 */
function variadic(array, ...numbers) {}
</code></pre>

<h4 id="features-functions-returns">5.5.6 Returns</h4>

<p>Function return types must be specified in the JSDoc directly above the function
definition, except in the case of same-signature <code>@override</code>s where all types
are omitted.</p>

<h4 id="features-functions-generics">5.5.7 Generics</h4>

<p>Declare generic functions and methods when necessary with <code>@template TYPE</code> in
the JSDoc above the class definition.</p>

<h4 id="features-functions-spread-operator">5.5.8 Spread operator</h4>

<p>Function calls may use the spread operator (<code>...</code>).  Prefer the spread operator
to <code>Function.prototype.apply</code> when an array or iterable is unpacked into
multiple parameters of a variadic function.  There is no space after the <code>...</code>.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code></pre>

<h3 id="features-string-literals">5.6 String literals</h3>

<h4 id="features-strings-use-single-quotes">5.6.1 Use single quotes</h4>

<p>Ordinary string literals are delimited with single quotes (<code>'</code>), rather than
double quotes (<code>"</code>).</p>

<p>Tip: if a string contains a single quote character, consider using a template
string to avoid having to escape the quote.</p>

<p>Ordinary string literals may not span multiple lines.</p>

<h4 id="features-strings-template-strings">5.6.2 Template strings</h4>

<p>Use template strings (delimited with <code>`</code>) over complex string
concatenation, particularly if multiple string literals are involved. Template
strings may span multiple lines.</p>

<p>If a template string spans multiple lines, it does not need to follow the
indentation of the enclosing block, though it may if the added whitespace does
not matter.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code></pre>

<h4 id="features-strings-no-line-continuations">5.6.3 No line continuations</h4>

<p>Do not use <em>line continuations</em> (that is, ending a line inside a string literal
with a backslash) in either ordinary or template string literals. Even though
ES5 allows this, it can lead to tricky errors if any trailing whitespace comes
after the slash, and is less obvious to readers.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';
</code></pre>

<p>Instead, write</p>

<pre><code class="language-js prettyprint">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
</code></pre>

<h3 id="features-number-literals">5.7 Number literals</h3>

<p>Numbers may be specified in decimal, hex, octal, or binary.  Use exactly <code>0x</code>,
<code>0o</code>, and <code>0b</code> prefixes, with lowercase letters, for hex, octal, and binary,
respectively.  Never include a leading zero unless it is immediately followed by
<code>x</code>, <code>o</code>, or <code>b</code>.</p>

<h3 id="features-control-structures">5.8 Control structures</h3>

<h4 id="features-for-loops">5.8.1 For loops</h4>

<p>With ES6, the language now has three different kinds of <code>for</code> loops.  All may be
used, though <code>for</code>-<code>of</code> loops should be preferred when possible.</p>

<p><code>for</code>-<code>in</code> loops may only be used on dict-style objects (see
<a href="#features-objects-mixing-keys">??</a>), and should not be used to iterate over an
array.  <code>Object.prototype.hasOwnProperty</code> should be used in <code>for</code>-<code>in</code> loops to
exclude unwanted prototype properties.  Prefer <code>for</code>-<code>of</code> and <code>Object.keys</code> over
<code>for</code>-<code>in</code> when possible.</p>

<h4 id="features-exceptions">5.8.2 Exceptions</h4>

<p>Exceptions are an important part of the language and should be used whenever
exceptional cases occur.  Always throw <code>Error</code>s or subclasses of <code>Error</code>: never
throw string literals or other objects.  Always use <code>new</code> when constructing an
<code>Error</code>.</p>

<p>Custom exceptions provide a great way to convey additional error information
from functions.  They should be defined and used wherever the native <code>Error</code>
type is insufficient.</p>

<p>Prefer throwing exceptions over ad-hoc error-handling approaches (such as
passing an error container reference type, or returning an object with an error
property).</p>

<h5 id="features-empty-catch-blocks">5.8.2.1 Empty catch blocks</h5>

<p>It is very rarely correct to do nothing in response to a caught exception. When
it truly is appropriate to take no action whatsoever in a catch block, the
reason this is justified is explained in a comment.</p>

<pre><code class="language-js prettyprint">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code></pre>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">   try {
    shouldFail();
    fail('expected an error');
  }
  catch (expected) {}
</code></pre>

<p>Tip: Unlike in some other languages, patterns like the above simply don&#8217;t work
since this will catch the error thrown by <code>fail</code>. Use <code>assertThrows()</code> instead.</p>

<h4 id="features-switch-statements">5.8.3 Switch statements</h4>

<p>Terminology Note: Inside the braces of a switch block are one or more statement groups. Each statement group consists of one or more switch labels (either <code>case FOO:</code> or <code>default:</code>), followed by one or more statements.</p>

<h5 id="features-switch-fall-through">5.8.3.1 Fall-through: commented</h5>

<p>Within a switch block, each statement group either terminates abruptly (with a
<code>break</code>, <code>return</code> or <code>throw</code>n exception), or is marked with a comment to
indicate that execution will or might continue into the next statement
group. Any comment that communicates the idea of fall-through is sufficient
(typically <code>// fall through</code>). This special comment is not required in the last
statement group of the switch block.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code></pre>

<h5 id="features-switch-default-case">5.8.3.2 The <code>default</code> case is present</h5>

<p>Each switch statement includes a <code>default</code> statement group, even if it contains
no code.</p>

<h3 id="features-this">5.9 this</h3>

<p>Only use <code>this</code> in class constructors and methods, or in arrow functions defined
within class constructors and methods. Any other uses of <code>this</code> must have an
explicit <code>@this</code> declared in the immediately-enclosing function&#8217;s JSDoc.</p>

<p>Never use <code>this</code> to refer to the global object, the context of an <code>eval</code>, the
target of an event, or unnecessarily <code>call()</code>ed or <code>apply()</code>ed functions.</p>

<h3 id="disallowed-features">5.10 Disallowed features</h3>

<h4 id="disallowed-features-with">5.10.1 with</h4>

<p>Do not use the <code>with</code> keyword.  It makes your code harder to understand and has
been banned in strict mode since ES5.</p>

<h4 id="disallowed-features-dynamic-code-evaluation">5.10.2 Dynamic code evaluation</h4>

<p>Do not use <code>eval</code> or the <code>Function(...string)</code> constructor (except for code
loaders).  These features are potentially dangerous and simply do not work in
CSP environments.</p>

<h4 id="disallowed-features-automatic-semicolon-insertion">5.10.3 Automatic semicolon insertion</h4>

<p>Always terminate statements with semicolons (except function and class
declarations, as noted above).</p>

<h4 id="disallowed-features-non-standard-features">5.10.4 Non-standard features</h4>

<p>Do not use non-standard features.  This includes old features that have been
removed (e.g., <code>WeakMap.clear</code>), new features that are not yet standardized
(e.g., the current TC39 working draft, proposals at any stage, or proposed but
not-yet-complete web standards), or proprietary features that are only
implemented in some browsers.  Use only features defined in the current ECMA-262
or WHATWG standards.  (Note that projects writing against specific APIs, such as
Chrome extensions or Node.js, can obviously use those APIs).  Non-standard
language &#8220;extensions&#8221; (such as those provided by some external transpilers) are
forbidden.</p>

<h4 id="disallowed-features-wrapper-objects">5.10.5 Wrapper objects for primitive types</h4>

<p>Never use <code>new</code> on the primitive object wrappers (<code>Boolean</code>, <code>Number</code>, <code>String</code>,
<code>Symbol</code>), nor include them in type annotations.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
</code></pre>

<p>The wrappers may be called as functions for coercing (which is preferred over
using <code>+</code> or concatenating the empty string) or creating symbols.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected
</code></pre>

<h4 id="disallowed-features-modifying-builtin-objects">5.10.6 Modifying builtin objects</h4>

<p>Never modify builtin types, either by adding methods to their constructors or to
their prototypes.  Avoid depending on libraries that do this.  Note that the
JSCompiler&#8217;s runtime library will provide standards-compliant polyfills where
possible; nothing else may modify builtin objects.</p>

<p>Do not add symbols to the global object unless absolutely necessary
(e.g. required by a third-party API).</p>

<h2 id="naming">6 Naming</h2>

<h3 id="naming-rules-common-to-all-identifiers">6.1 Rules common to all identifiers</h3>

<p>Identifiers use only ASCII letters and digits, and, in a small number of cases
noted below, underscores and very rarely (when required by frameworks like
Angular) dollar signs.</p>

<p>Give as descriptive a name as possible, within reason. Do not worry about saving
horizontal space as it is far more important to make your code immediately
understandable by a new reader. Do not use abbreviations that are ambiguous or
unfamiliar to readers outside your project, and do not abbreviate by deleting
letters within a word.</p>

<pre><code class="language-js prettyprint">priceCountReader      // No abbreviation.
numErrors             // "num" is a widespread convention.
numDnsConnections     // Most people know what "DNS" stands for.
</code></pre>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">n                     // Meaningless.
nErr                  // Ambiguous abbreviation.
nCompConns            // Ambiguous abbreviation.
wgcConnections        // Only your group knows what this stands for.
pcReader              // Lots of things can be abbreviated "pc".
cstmrId               // Deletes internal letters.
kSecondsPerDay        // Do not use Hungarian notation.
</code></pre>

<h3 id="naming-rules-by-identifier-type">6.2 Rules by identifier type</h3>

<h4 id="naming-package-names">6.2.1 Package names</h4>

<p>Package names are all <code>lowerCamelCase</code>. For example,
<code>my.exampleCode.deepSpace</code>, but not <code class="badcode">my.examplecode.deepspace</code> or <code class="badcode">my.example_code.deep_space</code>.</p>

<h4 id="naming-class-names">6.2.2 Class names</h4>

<p>Class, interface, record, and typedef names are written in <code>UpperCamelCase</code>.
Unexported classes are simply locals: they are not marked <code>@private</code> and
therefore are not named with a trailing underscore.</p>

<p>Type names are typically nouns or noun phrases. For example, <code>Request</code>,
<code>ImmutableList</code>, or <code>VisibilityMode</code>.  Additionally, interface names may
sometimes be adjectives or adjective phrases instead (for example, <code>Readable</code>).</p>

<h4 id="naming-method-names">6.2.3 Method names</h4>

<p>Method names are written in <code>lowerCamelCase</code>.  Private methods&#8217; names must end
with a trailing underscore.</p>

<p>Method names are typically verbs or verb phrases. For example, <code>sendMessage</code> or
<code>stop_</code>.  Getter and setter methods for properties are never required, but if
they are used they should be named <code>getFoo</code> (or optionally <code>isFoo</code> or <code>hasFoo</code>
for booleans), or <code>setFoo(value)</code> for setters.</p>

<p>Underscores may also appear in JsUnit test method names to separate logical
components of the name. One typical pattern is <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>,
for example <code>testPop_emptyStack</code>. There is no One Correct Way to name test
methods.</p>

<h4 id="naming-enum-names">6.2.4 Enum names</h4>

<p>Enum names are written in <code>UpperCamelCase</code>, similar to classes, and should
generally be singular nouns.  Individual items within the enum are named in
<code>CONSTANT_CASE</code>.</p>

<h4 id="naming-constant-names">6.2.5 Constant names</h4>

<p>Constant names use <code>CONSTANT_CASE</code>: all uppercase letters, with words separated
by underscores. There is no reason for a constant to be named with a trailing
underscore, since private static properties can be replaced by (implicitly
private) module locals.</p>

<h5 id="naming-definition-of-constant">6.2.5.1 Definition of &#8220;constant&#8221;</h5>

<p>Every constant is a <code>@const</code> static property or a module-local <code>const</code>
declaration, but not all <code>@const</code> static properties and module-local <code>const</code>s
are constants. Before choosing constant case, consider whether the field really
feels like a <em>deeply immutable</em> constant. For example, if any of that instance's
observable state can change, it is almost certainly not a constant. Merely
intending to never mutate the object is generally not enough.</p>

<p>Examples:</p>

<pre><code class="language-js prettyprint">// Constants
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// Not constants
let letVariable = 'non-const';
class MyClass { constructor() { /** @const */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';
const /** Set&lt;String&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // mirrors imported name
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>

<p>Constants&#8217; names are typically nouns or noun phrases.</p>

<h5 id="naming-local-aliases">6.2.5.1 Local aliases</h5>

<p>Local aliases should be used whenever they improve readability over
fully-qualified names.  Follow the same rules as <code>goog.require</code>s
(<a href="#file-goog-require">??</a>), maintaining the last part of the aliased name.
Aliases may also be used within functions.  Aliases must be <code>const</code>.</p>

<p>Examples:</p>

<pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code></pre>

<h4 id="naming-non-constant-field-names">6.2.6 Non-constant field names</h4>

<p>Non-constant field names (static or otherwise) are written in <code>lowerCamelCase</code>,
with a trailing underscore for private fields.</p>

<p>These names are typically nouns or noun phrases. For example, <code>computedValues</code>
or <code>index_</code>.</p>

<h4 id="naming-parameter-names">6.2.7 Parameter names</h4>

<p>Parameter names are written in <code>lowerCamelCase</code>.  Note that this applies even if
the parameter expects a constructor.</p>

<p>One-character parameter names should not be used in public methods.</p>

<p><strong>Exception</strong>: When required by a third-party framework, parameter names may
begin with a <code>$</code>.  This exception does not apply to any other identifiers
(e.g. local variables or properties).</p>

<h4 id="naming-local-variable-names">6.2.8 Local variable names</h4>

<p>Local variable names are written in <code>lowerCamelCase</code>, except for module-local
(top-level) constants, as described above.  Constants in function scopes are
still named in <code>lowerCamelCase</code>.  Note that lowerCamelCase applies even if the
variable holds a constructor.</p>

<h4 id="naming-template-parameter-names">6.2.9 Template parameter names</h4>

<p>Template parameter names should be concise, single-word or single-letter
identifiers, and must be all-caps, such as <code>TYPE</code> or <code>THIS</code>.</p>

<h3 id="naming-camel-case-defined">6.3 Camel case: defined</h3>

<p>Sometimes there is more than one reasonable way to convert an English phrase
into camel case, such as when acronyms or unusual constructs like <q>IPv6</q> or
<q>iOS</q> are present. To improve predictability, Google Style specifies the
following (nearly) deterministic scheme.</p>

<p>Beginning with the prose form of the name:</p>

<ol>
<li>Convert the phrase to plain ASCII and remove any apostrophes. For example,
<q>M&#252;ller's algorithm</q> might become <q>Muellers algorithm</q>.</li>
<li>Divide this result into words, splitting on spaces and any remaining
punctuation (typically hyphens).
<ol>
<li>Recommended: if any word already has a conventional camel case
appearance in common usage, split this into its constituent parts (e.g.,
<q>AdWords</q> becomes <q>ad words</q>). Note that a word such as <q>iOS</q> is not
really in camel case per se; it defies any convention, so this
recommendation does not apply.</li>
</ol></li>
<li>Now lowercase everything (including acronyms), then uppercase only the first
character of:
<ol>
<li>&#8230; each word, to yield upper camel case, or</li>
<li>&#8230; each word except the first, to yield lower camel case</li>
</ol></li>
<li>Finally, join all the words into a single identifier.</li>
</ol>

<p>Note that the casing of the original words is almost entirely disregarded.</p>

<p>Examples:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Prose form</th>
<th style="text-align: center">Correct</th>
<th style="text-align: center">Incorrect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center"><q>XML HTTP request</q></td>
<td style="text-align: center">XmlHttpRequest</td>
<td style="text-align: center">XMLHTTPRequest</td>
</tr>
<tr>
<td style="text-align: center"><q>new customer ID</q></td>
<td style="text-align: center">newCustomerId</td>
<td style="text-align: center">newCustomerID</td>
</tr>
<tr>
<td style="text-align: center"><q>inner stopwatch</q></td>
<td style="text-align: center">innerStopwatch</td>
<td style="text-align: center">innerStopWatch</td>
</tr>
<tr>
<td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
<td style="text-align: center">supportsIpv6OnIos</td>
<td style="text-align: center">supportsIPv6OnIOS</td>
</tr>
<tr>
<td style="text-align: center"><q>YouTube importer</q></td>
<td style="text-align: center">YouTubeImporter</td>
<td style="text-align: center">YoutubeImporter*</td>
</tr>
</tbody>
</table>

<p>*Acceptable, but not recommended.</p>

<p>Note: Some words are ambiguously hyphenated in the English language: for example <q>nonempty</q> and <q>non-empty</q> are both correct, so the method names checkNonempty and checkNonEmpty are likewise both correct.</p>

<h2 id="jsdoc">7 JSDoc</h2>

<p><a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">JSDoc</a> is used on all classes, fields, and methods.</p>

<h3 id="jsdoc-general-form">7.1 General form</h3>

<p>The basic formatting of JSDoc blocks is as seen in this example:</p>

<pre><code class="language-js prettyprint">/**
 * Multiple lines of JSDoc text are written here,
 * wrapped normally.
 * @param {number} arg A number to do something to.
 */
function doSomething(arg) { &#8230; }
</code></pre>

<p>or in this single-line example:</p>

<pre><code class="language-js prettyprint">/** @const @private {!Foo} A short bit of JSDoc. */
this.foo_ = foo;
</code></pre>

<p>If a single-line comment overflows into multiple lines, it must use the
multi-line style with <code>/**</code> and <code>*/</code> on their own lines.</p>

<p>Many tools extract metadata from JSDoc comments to perform code validation and
optimization.  As such, these comments <strong>must</strong> be well-formed.</p>

<h3 id="jsdoc-markdown">7.2 Markdown</h3>

<p>JSDoc is written in Markdown, though it may include HTML when necessary.</p>

<p>Note that tools that automatically extract JSDoc (e.g. <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) will often
ignore plain text formatting, so if you did this:</p>

<pre><code class="language-js prettyprint badcode">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code></pre>

<p>it would come out like this:</p>

<pre><code>Computes weight based on three factors: items sent items received last timestamp
</code></pre>

<p>Instead, write a Markdown list:</p>

<pre><code class="language-js prettyprint">/**
 * Computes weight based on three factors:
 *  - items sent
 *  - items received
 *  - last timestamp
 */
</code></pre>

<h3 id="jsdoc-tags">7.3 JSDoc tags</h3>

<p>Google style allows a subset of JSDoc tags.  See
<a href="#appendices-jsdoc-tag-reference">??</a> for the complete list.  Most tags must
occupy their own line, with the tag at the beginning of the line.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
</code></pre>

<p>Simple tags that do not require any additional data (such as <code>@private</code>,
<code>@const</code>, <code>@final</code>, <code>@export</code>) may be combined onto the same line, along with an
optional type when appropriate.</p>

<pre><code class="language-js prettyprint">/**
 * Place more complex annotations (like "implements" and "template")
 * on their own lines.  Multiple simple tags (like "export" and "final")
 * may be combined in one line.
 * @export @final
 * @implements {Iterable&lt;TYPE&gt;}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Some object.
   * @param {number=} num An optional number.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array&lt;!ObjType|number&gt;} */
    this.data_ = [obj, num];
  }
}
</code></pre>

<p>There is no hard rule for when to combine tags, or in which order, but be
consistent.</p>

<p>For general information about annotating types in JavaScript see
<a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a> and <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
System</a>.</p>

<h3 id="jsdoc-line-wrapping">7.4 Line wrapping</h3>

<p>Line-wrapped block tags are indented four spaces.  Wrapped description text may
be lined up with the description on previous lines, but this horizontal
alignment is discouraged.</p>

<pre><code class="language-js prettyprint">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
exports.method = function(foo) {
  return 5;
};
</code></pre>

<p>Do not indent when wrapping a <code>@fileoverview</code> description.</p>

<h3 id="jsdoc-top-file-level-comments">7.5 Top/file-level comments</h3>

<p>A file may have a top-level file overview. A copyright notice , author information, and
default <a href="#jsdoc-visibility-annotations">visibility level</a> are optional.  File overviews are generally recommended whenever a
file consists of more than a single class definition. The top level comment is
designed to orient readers unfamiliar with the code to what is in this file. If
present, it may provide a description of the file's contents and any
dependencies or compatibility information. Wrapped lines are not indented.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @package
 */
</code></pre>

<h3 id="jsdoc-class-comments">7.6 Class comments</h3>

<p>Classes, interfaces and records must be documented with a description and any
template parameters, implemented interfaces, visibility, or other appropriate
tags. The class description should provide the reader with enough information to
know how and when to use the class, as well as any additional considerations
necessary to correctly use the class. Textual descriptions may be omitted on the
constructor. <code>@constructor</code> and <code>@extends</code> annotations are not used with the
<code>class</code> keyword unless the class is being used to declare an <code>@interface</code> or
it extends a generic class.</p>

<pre><code class="language-js prettyprint">/**
 * A fancier event target that does cool things.
 * @implements {Iterable&lt;string&gt;}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 An argument that makes this more interesting.
   * @param {!Array&lt;number&gt;} arg2 List of numbers to be processed.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Records are also helpful.
 * @extends {Iterator&lt;TYPE&gt;}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} The next item in line to be returned. */
  next() {}
}
</code></pre>

<h3 id="jsdoc-enum-and-typedef-comments">7.7 Enum and typedef comments</h3>

<p>Enums and typedefs must be documented.  Public enums and typedefs must have a
non-empty description.  Individual enum items may be documented with a JSDoc
comment on the preceding line.</p>

<pre><code class="language-js prettyprint">/**
 * A useful type union, which is reused often.
 * @typedef {!Bandersnatch|!BandersnatchType}
 */
let CoolUnionType;


/**
 * Types of bandersnatches.
 * @enum {string}
 */
const BandersnatchType = {
  /** This kind is really frumious. */
  FRUMIOUS: 'frumious',
  /** The less-frumious kind. */
  MANXOME: 'manxome',
};
</code></pre>

<p>Typedefs are useful for defining short record types, or aliases for unions,
complex functions, or generic types.
Typedefs should be avoided for record types with many fields, since they do not
allow documenting individual fields, nor using templates or recursive
references.
For large record types, prefer <code>@record</code>.</p>

<h3 id="jsdoc-method-and-function-comments">7.8 Method and function comments</h3>

<p>Parameter and return types must be documented. The <code>this</code> type should be
documented when necessary. Method, parameter, and return descriptions (but not
types) may be omitted if they are obvious from the rest of the method&#8217;s JSDoc or
from its signature. Method descriptions should start with a sentence written in
the third person declarative voice.  If a method overrides a superclass method,
it must include an <code>@override</code> annotation.  Overridden methods must include all
<code>@param</code> and <code>@return</code> annotations if any types are refined, but should omit
them if the types are all the same.</p>

<pre><code class="language-js prettyprint">/** This is a class. */
class SomeClass extends SomeBaseClass {
  /**
   * Operates on an instance of MyClass and returns something.
   * @param {!MyClass} obj An object that for some reason needs detailed
   *     explanation that spans multiple lines.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Whether something occurred.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /** @override */
  overriddenMethod(param) { ... }
}

/**
 * Demonstrates how top-level functions follow the same rules.  This one
 * makes an array.
 * @param {TYPE} arg
 * @return {!Array&lt;TYPE&gt;}
 * @template TYPE
 */
function makeArray(arg) { ... }
</code></pre>



<p>Anonymous functions do not require JSDoc, though parameter types may be specified inline if the automatic type inference is insufficient.</p>

<pre><code class="language-js prettyprint">promise.then(
    (/** !Array&lt;number|string&gt; */ items) =&gt; {
      doSomethingWith(items);
      return /** @type {string} */ (items[0]);
    });
</code></pre>

<h3 id="jsdoc-property-comments">7.9 Property comments</h3>

<p>Property types must be documented. The description may be omitted for private
properties, if name and type provide enough documentation for understanding the
code.</p>

<p>Publicly exported constants are commented the same way as properties.  Explicit
types may be omitted for <code>@const</code> properties initialized from an expression with
an obviously known type.</p>

<p>Tip: A <code>@const</code> property&#8217;s type can be considered &#8220;obviously known&#8221; if it is
assigned directly from a constructor parameter with a declared type, or directly
from a function call with a declared return type.  Non-const properties and
properties assigned from more complex expressions should have their types
declared explicitly.</p>

<pre><code class="language-js prettyprint">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Maximum number of things per pane.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * The number of times we'll try before giving up.
 * @const
 */
MyClass.RETRY_COUNT = 33;
</code></pre>

<h3 id="jsdoc-type-annotations">7.10 Type annotations</h3>

<p>Type annotations are found on <code>@param</code>, <code>@return</code>, <code>@this</code>, and <code>@type</code> tags,
and optionally on <code>@const</code>, <code>@export</code>, and any visibility tags.  Type
annotations attached to JSDoc tags must always be enclosed in braces.</p>

<h4 id="jsdoc-nullability">7.10.1 Nullability</h4>

<p>The type system defines modifiers <code>!</code> and <code>?</code> for non-null and nullable,
respectively.  Primitive types (<code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>,
<code>symbol</code>, and <code>function(...): ...</code>) and record literals (<code>{foo: string, bar:
number}</code>) are non-null by default.  Do not add an explicit <code>!</code> to these types.
Object types (<code>Array</code>, <code>Element</code>, <code>MyClass</code>, etc) are nullable by default, but
cannot be immediately distinguished from a name that is <code>@typedef</code>&#8217;d to a
non-null-by-default type.  As such, all types except primitives and record
literals must be annotated explicitly with either <code>?</code> or <code>!</code> to indicate whether
they are nullable or not.</p>

<h4 id="jsdoc-type-casts">7.10.2 Type Casts</h4>

<p>In cases where type checking doesn't accurately infer the type of an expression,
it is possible to tighten the type by adding a type annotation comment and
enclosing the expression in parentheses. Note that the parentheses are required.</p>

<pre><code class="language-js prettyprint">/** @type {number} */ (x)
</code></pre>

<h4 id="jsdoc-template-parameter-types">7.10.3 Template Parameter Types</h4>

<p>Always specify template parameters. This way compiler can do a better job and it
makes it easier for readers to understand what code does.</p>

<p>Bad:</p>

<pre><code class="language-js prettyprint badcode">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;
</code></pre>

<p>Good:</p>

<pre><code class="language-js prettyprint">const /** !Object&lt;string, !User&gt; */ users = {};
const /** !Array&lt;string&gt; */ books = [];
const /** !Promise&lt;!Response&gt; */ response = ...;

const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object&lt;string, *&gt; */ mapOfEverything = {};
</code></pre>

<p>Cases when template parameters should not be used:</p>

<ul>
<li><code>Object</code> is used for type hierarchy and not as map-like structure.</li>
</ul>

<h3 id="jsdoc-visibility-annotations">7.11 Visibility annotations</h3>

<p>Visibility annotations (<code>@private</code>, <code>@package</code>, <code>@protected</code>) may be specified
in a <code>@fileoverview</code> block, or on any exported symbol or property.  Do not
specify visibility for local variables, whether within a function or at the top
level of a module.  All <code>@private</code> names must end with an underscore.</p>

<h2 id="policies">8 Policies</h2>

<h3 id="policies-be-consistent">8.1 Issues unspecified by Google Style: Be Consistent!</h3>

<p>For any style question that isn't settled definitively by this specification,
prefer to do what the other code in the same file is already doing. If that
doesn't resolve the question, consider emulating the other files in the same
package.</p>

<h3 id="policies-compiler-warnings">8.2 Compiler warnings</h3>

<h4 id="policies-use-a-standard-warning-set">8.2.1 Use a standard warning set</h4>

<p>
As far as possible projects should use <code>--warning_level=VERBOSE</code>.
</p>

<h4 id="policies-how-to-handle-a-warning">8.2.2 How to handle a warning</h4>

<p>Before doing anything, make sure you understand exactly what the warning is
telling you. If you're not positive why a warning is appearing, ask for help
.</p>

<p>Once you understand the warning, attempt the following solutions in order:</p>

<ol>
<li><strong>First, fix it or work around it.</strong> Make a strong attempt to actually
address the warning, or find another way to accomplish the task that avoids
the situation entirely.</li>
<li><strong>Otherwise, determine if it's a false alarm.</strong> If you are convinced that
the warning is invalid and that the code is actually safe and correct, add a
comment to convince the reader of this fact and apply the <code>@suppress</code>
annotation.</li>
<li><strong>Otherwise, leave a TODO comment.</strong> This is a <strong>last resort</strong>.  If you do
this, <strong>do not suppress the warning.</strong> The warning should be visible until
it can be taken care of properly.</li>
</ol>

<h4 id="policies-suppress-a-warning-at-the-narrowest-reasonable-scope">8.2.3 Suppress a warning at the narrowest reasonable scope</h4>

<p>Warnings are suppressed at the narrowest reasonable scope, usually that of a single local variable or very small method. Often a variable or method is extracted for that reason alone.</p>

<p>Example</p>

<pre><code class="language-js prettyprint">/** @suppress {uselessCode} Unrecognized 'use asm' declaration */
function fn() {
  'use asm';
  return 0;
}
</code></pre>

<p>Even a large number of suppressions in a class is still better than blinding the
entire class to this type of warning.</p>

<h3 id="policies-deprecation">8.3 Deprecation</h3>

<p>Mark deprecated methods, classes or interfaces with <code>@deprecated</code> annotations. A
deprecation comment must include simple, clear directions for people to fix
their call sites.</p>

<h3 id="policies-code-not-in-google-style">8.4 Code not in Google Style</h3>

<p>You will occasionally encounter files in your codebase that are not in proper
Google Style. These may have come from an acquisition, or may have been written
before Google Style took a position on some issue, or may be in non-Google Style
for any other reason.</p>

<h4 id="policies-reformatting-existing-code">8.4.1 Reformatting existing code</h4>

<p>When updating the style of existing code, follow these guidelines.</p>

<ol>
<li>It is not required to change all existing code to meet current style
guidelines.  Reformatting existing code is a trade-off between code churn
and consistency. Style rules evolve over time and these kinds of tweaks to
maintain compliance would create unnecessary churn.  However, if significant
changes are being made to a file it is expected that the file will be in
Google Style.</li>
<li>Be careful not to allow opportunistic style fixes to muddle the focus of a
CL. If you find yourself making a lot of style changes that aren&#8217;t critical
to the central focus of a CL, promote those changes to a separate CL.</li>
</ol>

<h4 id="policies-newly-added-code-use-google-style">8.4.2 Newly added code: use Google Style</h4>

<p>Brand new files use Google Style, regardless of the style choices of other files
in the same package.</p>

<p>When adding new code to a file that is not in Google Style, reformatting the
existing code first is recommended, subject to the advice in
<a href="#policies-reformatting-existing-code">??</a>.</p>

<p>If this reformatting is not done, then new code should be as consistent as
possible with existing code in the same file, but must not violate the style
guide.</p>

<h3 id="policies-local-style-rules">8.5 Local style rules</h3>

<p>Teams and projects may adopt additional style rules beyond those in this
document, but must accept that cleanup changes may not abide by these additional
rules, and must not block such cleanup changes due to violating any additional
rules. Beware of excessive rules which serve no purpose. The style guide does
not seek to define style in every possible scenario and neither should you.</p>

<h3 id="policies-generated-code-mostly-exempt">8.6 Generated code: mostly exempt</h3>

<p>Source code generated by the build process is not required to be in Google
Style. However, any generated identifiers that will be referenced from
hand-written source code must follow the naming requirements. As a special
exception, such identifiers are allowed to contain underscores, which may help
to avoid conflicts with hand-written identifiers.</p>

<h2 id="appendices">9 Appendices</h2>

<h3 id="appendices-jsdoc-tag-reference">9.1 JSDoc tag reference</h3>

<p>JSDoc serves multiple purposes in JavaScript.  In addition to being used to
generate documentation it is also used to control tooling.  The best known are
the Closure Compiler type annotations.</p>

<h4 id="appendices-type-annotations">9.1.1 Type annotations and other Closure Compiler annotations</h4>

<p>Documentation for JSDoc used by the Closure Compiler is described in
<a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a> and <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
System</a>.</p>

<h4 id="appendices-documentation-annotations">9.1.2 Documentation annotations</h4>

<p>In addition to the JSDoc described in <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure
Compiler</a> the following tags are common and well supported by various
documentation generations tools (such as <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) for purely documentation
purposes.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@author</code> or <code>@owner</code>
      </td><td><code>@author username@google.com (First Last)</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Utilities for handling textareas.
 * @author <a href="mailto:kuth@google.com">kuth@google.com</a> (Uthur Pendragon)
 */
 </pre>
      </td><td>Document the author of a file or the owner of a test, generally only
        used in the <code>@fileoverview</code> comment. The <code>@owner</code> tag is used by the
        unit test dashboard to determine who owns the test results.
        <p>Not recommended.
    </p></td></tr><tr>
      <td><code>@bug</code>
      </td><td><code>@bug bugnumber</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @bug 1234567 */
function testSomething() {
  // &#8230;
}

<p>/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // &#8230;
}
</p></pre>
      </td><td>Indicates what bugs the given test function regression tests.
        <p>Multiple bugs should each have their own <code>@bug</code> line, to make
        searching for regression tests as easy as possible.
    </p></td></tr><tr>
      <td><code>@code</code>
      </td><td><code>{@code ...}</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Moves to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it
 * passes the end of the range.
 * @return {!Node} The node at the next position.
 */
goog.dom.RangeIterator.prototype.next = function() {
  // &#8230;
};
</pre>
      </td><td>Indicates that a term in a JSDoc description is code so it may be
        correctly formatted in generated documentation.
    </td></tr><tr>
      <td><code>@see</code>
      </td><td><code>@see Link</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */
 </pre>
       </td><td>Reference a lookup to another class function or method.
    </td></tr><tr>
      <td><code>@supported</code>
      </td><td><code>@supported Description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the
 * browsers' event systems.
 * @supported IE10+, Chrome, Safari
 */
</pre>
      </td><td>Used in a fileoverview to indicate what browsers are supported by
        the file.
    </td></tr><tr>
      <td><code>@desc</code>
      </td><td><code>@desc Message description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @desc Notifying a user that their account has been created. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Your account has been successfully created.');
 </pre>
      </td></tr></tbody></table></p>

<p>You may also see other types of JSDoc annotations in third-party code. These
annotations appear in the <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc Toolkit Tag Reference</a> but are not considered
part of valid Google style.</p>

<h4 id="appendices-framework-specific-annotations">9.1.3 Framework specific annotations</h4>

<p>The following annotations are specific to a particular framework.
<table>
  <thead>
    <tr>
      <th>Framework
      </th><th>Tag
      </th><th>Documentation
  </th></tr></thead><tbody>
    <tr>
      <td>Angular 1
      </td><td><code>@ngInject</code>
      </td></tr><tr>
      <td>Polymer
      </td><td><code>@polymerBehavior</code>
      </td><td>
          
            <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass">https://github.com/google/closure-compiler/wiki/Polymer-Pass</a>
          
    </td></tr></tbody></table></p>

<h4 id="appendices-notes-about-standard-closure-compiler-annotations">9.1.4 Notes about standard Closure Compiler annotations</h4>

<p>The following tags used to be standard but are now deprecated.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@expose</code>
      </td><td><code>@expose</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@export</code> and/or <code>@nocollapse</code>
        instead.</strong>
    </td></tr><tr>
      <td><code>@inheritDoc</code>
      </td><td><code>@inheritDoc</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@override</code> instead.</strong>
</td></tr></tbody></table></p>

<h3 id="appendices-commonly-misunderstood-style-rules">9.2 Commonly misunderstood style rules</h3>

<p>Here is a collection of lesser-known or commonly misunderstood facts about
Google Style for JavaScript. (The following are true statements; this is not a
list of <q>myths.</q>)</p>

<ul>
<li>Neither a copyright statement nor <code>@author</code> credit is required in a source
file. (Neither is explicitly recommended, either.)</li>
<li>Aside from the constructor coming first
(<a href="#features-classes-constructors">??</a>), there is no <q>hard and fast</q> rule
governing how to order the members of a class (<a href="#features-classes">??</a>).</li>
<li>Empty blocks can usually be represented concisely as <code>{}</code>, as detailed in
(<a href="#formatting-empty-blocks">??</a>).</li>
<li>The prime directive of line-wrapping is: prefer to break at a higher
syntactic level (<a href="#formatting-where-to-break">??</a>).</li>
<li>Non-ASCII characters are allowed in string literals, comments and Javadoc,
and in fact are recommended when they make the code easier to read than the
equivalent Unicode escape would (<a href="#non-ascii-characters">??</a>).</li>
</ul>

<h3 id="appendices-style-related-tools">9.3 Style-related tools</h3>

<p>The following tools exist to support various aspects of Google Style.</p>

<h4 id="appendices-tools-closure-compiler">9.3.1 Closure Compiler</h4>

<p>This program performs type checking and other checks,
optimizations and other transformations (such as ECMAScript 6 to ECMAScript 5
code lowering).</p>

<h4 id="appendices-clang-format">9.3.2 <code>clang-format</code></h4>

<p>This program  reformats
JavaScript source code into Google Style, and also follows a number of
non-required but frequently readability-enhancing formatting practices.</p>

<p><code>clang-format</code> is not required. Authors are allowed to change its output, and
reviewers are allowed to ask for such changes; disputes are worked out in the
usual way. However, subtrees may choose to opt in to such enforcement locally.</p>

<h4 id="appendices-closure-compiler-linter">9.3.3 Closure compiler linter</h4>

<p>This program  checks for a
variety of missteps and anti-patterns.
</p>

<h4 id="appendices-conformance-framework">9.3.4 Conformance framework</h4>

<p>The JS Conformance Framework is a tool that is part of the Closure Compiler that
provides developers a simple means to specify a set of additional checks to be
run against their code base above the standard checks.  Conformance checks can,
for example, forbid access to a certain property, or calls to a certain
function, or missing type information (unknowns).</p>

<p>These rules are commonly used to enforce critical restrictions (such as defining
globals, which could break the codebase) and security patterns (such as using
<code>eval</code> or assigning to <code>innerHTML</code>), or more loosely to improve code quality.</p>

<p>For additional information see the official documentation for the
<a href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework">JS Conformance Framework</a>.</p>

<h3 id="appendices-legacy-exceptions">9.4 Exceptions for legacy platforms</h3>

<h4 id="appendices-legacy-exceptions-overview">9.4.1 Overview</h4>

<p>This section describes exceptions and additional rules to be followed when
modern ECMAScript 6 syntax is not available to the code authors. Exceptions to
the recommended style are required when ECMAScript 6 syntax is not possible and
are outlined here:</p>

<ul>
<li>Use of <code>var</code> declarations is allowed</li>
<li>Use of <code>arguments</code> is allowed</li>
<li>Optional parameters without default values are allowed</li>
</ul>

<h4 id="appendices-legacy-exceptions-var">9.4.2 Use <code>var</code></h4>

<h5 id="appendices-legacy-exceptions-var-scope">9.4.2.1 <code>var</code> declarations are NOT block-scoped</h5>

<p><code>var</code> declarations are scoped to the beginning of the nearest enclosing
function, script or module, which can cause unexpected behavior, especially with
function closures that reference <code>var</code> declarations inside of loops. The
following code gives an example:</p>

<pre><code class="language-js prettyprint badcode">for (var i = 0; i &lt; 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// logs 2, 2, 2 -- NOT 0, 1, 2
// because `iteration` is function-scoped, not local to the loop.

</code></pre>

<h5 id="appendices-legacy-exceptions-var-declare">9.4.2.2 Declare variables as close as possible to first use</h5>

<p>Even though <code>var</code> declarations are scoped to the beginning of the enclosing
function, <code>var</code> declarations should be as close as possible to their first use,
for readability purposes. However, do not put a <code>var</code> declaration inside a block
if that variable is referenced outside the block. For example:</p>

<pre><code class="language-js prettyprint">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" could be declared here, but don't do that.
    count++;
  }
  console.log(count + ' items in y');
}
</code></pre>

<h5 id="appendices-legacy-exceptions-var-const">9.4.2.3 Use @const for constants variables</h5>

<p>For global declarations where the <code>const</code> keyword would be used, if it were
available, annotate the <code>var</code> declaration with @const instead (this is optional
for local variables).</p>

<h4 id="appendices-legacy-exceptions-function">9.4.3 Do not use block scoped functions declarations</h4>

<p>Do <strong>not</strong> do this:</p>

<pre><code class="language-js prettyprint badcode">if (x) {
  function foo() {}
}
</code></pre>

<p>While most JavaScript VMs implemented before ECMAScript 6 support function
declarations within blocks it was not standardized. Implementations were
inconsistent with each other and with the now-standard ECMAScript 6 behavior for
block scoped function declaration. ECMAScript 5 and prior only allow for
function declarations in the root statement list of a script or function and
explicitly ban them in block scopes in strict mode.</p>

<p>To get consistent behavior, instead use a <code>var</code> initialized with a function
expression to define a function within a block:</p>

<pre><code class="language-js prettyprint">if (x) {
  var foo = function() {};
}
</code></pre>

<h4 id="appendices-legacy-exceptions-goog-provide">9.4.4 Dependency management with <code>goog.provide</code>/<code>goog.require</code></h4>

<p><strong><code>goog.provide</code> is deprecated. All new files should use <code>goog.module</code>, even in
projects with existing <code>goog.provide</code> usage. The following rules are for
pre-existing goog.provide files, only.</strong></p>

<h5 id="appendices-legacy-exceptions-goog-provide-summary">9.4.4.1 Summary</h5>

<ul>
<li>Place all <code>goog.provide</code>s first, <code>goog.require</code>s second. Separate provides
from requires with an empty line.</li>
<li>Sort the entries alphabetically (uppercase first).</li>
<li>Don't wrap <code>goog.provide</code> and <code>goog.require</code> statements. Exceed 80 columns
if necessary.</li>
<li>Only provide top-level symbols.</li>
</ul>

<p>As of Oct 2016, <strong><code>goog.provide</code>/<code>goog.require</code> dependency management is
deprecated</strong>. All new files, even in projects using <code>goog.provide</code> for older
files, should use
<a href="#source-file-structure"><code>goog.module</code></a>.</p>

<p><code>goog.provide</code> statements should be grouped together and placed first. All
<code>goog.require</code> statements should follow. The two lists should be separated with
an empty line.</p>

<p>Similar to import statements in other languages, <code>goog.provide</code> and
<code>goog.require</code> statements should be written in a single line, even if they
exceed the 80 column line length limit.</p>

<p>The lines should be sorted alphabetically, with uppercase letters coming first:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');

</code></pre>

<p>All members defined on a class should be in the same file. Only top-level
classes should be provided in a file that contains multiple members defined on
the same class (e.g. enums, inner classes, etc).</p>

<p>Do this:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
</code></pre>

<p>Not this:</p>

<pre><code class="language-js prettyprint badcode">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code></pre>

<p>Members on namespaces may also be provided:</p>

<pre><code class="language-js prettyprint">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');
</code></pre>

<h5 id="appendices-legacy-exceptions-goog-scope">9.4.4.2 Aliasing with <code>goog.scope</code></h5>

<p><strong><code>goog.scope</code> is deprecated. New files should not use <code>goog.scope</code> even in
projects with existing goog.scope usage.</strong></p>

<p><code>goog.scope</code> may be used to shorten references to namespaced symbols in
code using <code>goog.provide</code>/<code>goog.require</code> dependency management.</p>

<p>Only one <code>goog.scope</code> invocation may be added per file. Always place it in
the global scope.</p>

<p>The opening <code>goog.scope(function() {</code> invocation must be preceded by exactly one
blank line and follow any <code>goog.provide</code> statements, <code>goog.require</code> statements,
or top-level comments. The invocation must be closed on the last line in the
file. Append <code>// goog.scope</code> to the closing statement of the scope. Separate the
comment from the semicolon by two spaces.</p>

<p>Similar to C++ namespaces, do not indent under <code>goog.scope</code> declarations.
Instead, continue from the 0 column.</p>

<p>Only make aliases for names that will not be re-assigned to another object
(e.g., most constructors, enums, and namespaces). Do not do this (see below for
how to alias a constructor):</p>

<pre><code class="language-js prettyprint badcode">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...
</code></pre>

<p>Names must be the same as the last property of the global that they are aliasing.</p>

<pre><code class="language-js prettyprint">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Alias new types after the constructor declaration.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Declare methods on the prototype as usual:
SomeType.prototype.findButton = function() {
  // Button as aliased above.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code></pre>

</div>
</body>
</html>
